# Chapter3
## 색인
: 일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것 -> 이 메타데이터는 이정표 역할을 해서 원하는 데이터를 찾는데 도움을 준다
- 데이터를 쓸 때마다 매번 색인도 갱신해야 되기 때문에 쓰기 속도를 느리게 만든다

### 해시 색인
- 인메모리 데이터 구조를 위한 해시 맵이 있으니 디스크 상의 데이터를 색인하기 위해 인메모리 데이터 구조를 사용하는 것은 어떨까?
  - 파일에 새로운 키-값 쌍을 추가할 때마다 방금 기록한 데이터의 오프셋을 바녕ㅇ하기 위해 해시맵도 갱신
  - 값을 조회하려면 해시맵을 사용해 데이터 파일에서 오프셋을 찾아 해당 위치를 구하고 값을 읽음
- 이렇게 파일에 추가만 한다면 결국 디스크 공간 부족
  - 해결방법: 특정 크기의 세그먼트로 로그를 나누는 방식
  - :세그먼트 파일들에 대해 컴팩션을 수행할 수 있다 -> 컴팩션은 로그에서 중복된 키를 버리고 각 키의 최신 갱신값만 유지
- 컴팩션: 세그먼트를 더 작게 만듬
  - 컴팩션을 수행할 때 동시에 여러 세그먼트들을 병합할 수 있음
  - 병합과정이 끝난 이후에는 읽기 요청은 이전 세그먼트 대신 새로 병합한 세그먼트를 사용하게끔 전환
  - 전환 후에는 이전 세그먼트 파일 삭제
- 해시 테이블 제한 사항 존재
  - 메모리에 저장해야 하므로 키가 너무 많으면 문제
  - 범위 질의에 효율적이지 않음 -> 범위 질의가 안되고 모든 개별키를 조회해야함

### SS 테이블: 키로 정렬된 문자열 테이블
- 병합정렬 알고리즘과 유사
- 다중 세그먼트가 동일한 키를 포함하는 경우 가장 최근 세그먼트의 값은 유지하고 오래된 세그먼트의 값은 버린다
- 키의 오프셋을 알고 있고 정렬돼 있으므로 오프셋으로 이동해 찾는 결과가 나올 때까지 스캔하면 된다
- 키로 데이터를 어떻게 정렬?
  - 디스크 상에 정렬된 구조를 유지하는 일은 가능하지만 메모리에 유지하는 것이 더 쉽다
  - 임의 순서로 키를 삽입하고 정렬된 순서로 해당 키를 다시 읽을 수 있다
  - 1. 쓰기가 들어오면 인메모리 균형트리 데이터 구조에 추가 -> 멤테이블
  - 2. 새로운 SS테이블 파일은 데이터베이스의 가장 최신 시그먼트가 된다 - SS테이블을 디스크에 기록하는 동안 쓰기는 새로운 멤테이블 인스턴스에 기록
  - 3. 읽기 요청을 제공하려면 먼저 멤테이블에서 키를 찾고 그 다음 디스크 상의 가장 최신 세그먼트에서 찾는다
  - 4. 가끔 세그먼트 파일을 합치고 덮어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 과정을 수행
- 문제점: 만약 데이터베이스가 고장나 아직 기록되지 않고 멤테이블에 있는 최신 쓰기 손실
  - 이런 문제를 피하기 위해 매번 쓰기를 즉시 추가할 수 있게 분리된 로그를 디스크 상에 유지해야함
  - 로그는 손상 후 멤테이블을 복원할 때만 필요하기 때문에 순서가 정렬되지 않아도 문제 없음
  - 멤테이블을 SS테이블로 기록하고 나면 해당 로그는 버릴 수 있다

## LSM 트리
- 백그라운드에서 연쇄적으로 SS테이블을 지속적으로 병합하는 것
- 데이터셋이 가능한 메모리보다 훨씬 더 크더라도 여전히 효과적
- 데이터가 정렬된 순서로 저장돼 있다면 범위 질의를 효과적으로 실행 가능
- 디스크 쓰기는 순차적이기 대문에 LSM 트리는 높은 쓰기 처리량 보장

### LSM 트리 장점
- B 트리 색인은 모든 데이터 조각을 최소한 두 번 기록해야 함 -> 쓰기 전 로그 한 번과 트리 페이지에 한 번 -> 오버헤드
- B트리 보다 쓰기 처리량을 높게 유지할 수 있다 -> 트리에서 여러 페이지를 덮어쓰는 것이 아니라 순차적으로 컴팩션된 SS테이블 파일을 쓰기 때문
- LSM 트리는 압축률이 좋다 - B트리는 파편화로 인해 사용하지 않는 디스크 공간 일부가 남는다
  - LSM 트리는 페이지 지향적이지 않고 주기적으로 파편화를 없애기 위해 SS테이블을 다시 기록하기 때문에 저장소 오버헤드 낮음

### LSM 트리 단점
- 컴팩션 과정이 때로는 진행 중인 읽기와 쓰기의 성능에 영향을 준다
- 비싼 컴팩션 연산이 끝날 때까지 요청이 대기해야하는 상황 발생 쉬움
- 데이터베이스가 점점 커질 수록 컴팩션을 위해 더 많은 디스크 대역혹 필요
- 

### 성능 최적화
- LSM 트리 알고리즘은 데이터베이스에 존재하지 않는 키를 찾는 경우 느릴 수 있음 -> 멤테이블을 확인한 다음 ㅣ가 존재하지 않는 다는 사실을 확인하기 전에는 가장 오래된 세그먼트까지 거슬러 올라가야 하기 때문
- 이런 접근을 최적화 하기 위해 -> "블룸 필터": 키가 데이터베이스에 존재하지 않음을 알려주므로 존재하지 않는 키를 위한 불필요한 디스크 읽기 절약 가능
- LSM 트리

## B 트리
- 가장 널리 사용되는 색인 구조
- 기본 쓰기 동작: 새로운 데이터를 디스크 상의 페이지에 덮어 쓴다
  - 덮어쓰기가 페이지의 위치를 변경하지 않는 다고 가정 -> 덮어쓰더라도 페이지를 가리키는 모든 참조는 온전하게 남는다
- 쓰기 전 로그: 트리 페이지에 변경된 내용을 적용하기 전에 모든 B 트리의 변경사항을 기록하는 추가 전용 파일
  - 고장 이후 복구될 때 일관성있는 상태로 B트리를 다시 복원하는데 사용

### B 트리 장점
- 각 키가 색인의 한 곳에만 정확하게 존재

### B 트리 최적화
- 변경된 페이지는 다른 위치에 기록하고 트리에 상위 페이지의 새로운 버전을 만들어 새로운 위치를 가리키게 한다
- 트리에 포인터를 추가 - 리프 페이지가 양쪽 형제 페이지에 대한 참조를 가지면 굳이 상위 페이지로 다시 이동하지 않아도 순서대로 키를 스캔할 수 있다

### B 트리 vs LMS 트리
- LSM 트리는 쓰기에서 더 빠르고 B 트리는 읽기에서 더 빠름
  - LSM트리가 읽기에서 느린 이유: 컴팩션 단계에 있는 여러가지 데이터 구조와 SS 테이블을 확인해야하기 때문

### 색인 안에 값 저장하기
- 힙 파일: 다른 곳에 저장된 로우를 가리키는 참조, 특정 순서없이 데이터를 저장
- 각 색인은 힙 파일에서 위치만 참조하고 실제 데이터는 일정한 곳에 유지
- 키를 변경하지 않고 값을 갱신할 때 효율적

### 다중 칼럼 색인
- 결합 색인
- 하나의 칼럼에 다른 칼럼을 추가하는 바식 - 하나의 키에 여러 필드를 단순히 결합
- 사용자가 지도에서 레스토랑을 찾을 때 네모난 지도 지역 내 모든 레스토랑을 찾음 -> 이차원 범위 질의 필요 
  - 이차원 위치를 공간 채움 곡선을 이용해 단일 숫자로 변환 한 다음 일반 B트리 사용하는 방법 있음

### 전문 검색과 퍼지 색인
- 전문 검색 엔진은 해당 단어의 동의어로 질의를 확장
- 키를 찾는 데 필요한 정렬 파일의 오프셋을 질의에 알려주는 데 사용

```
논의주제)
멤테이블이라는 것은 요청을 저장소에 반영하기 전에 저장해놓고, 저장소에 요청이 반영되면 멤테이블에 저장됐던건 사라지는 건가요?
제가 잘 이해한 것인지 궁금합니다. SS테이블, 멤테이블에 대해 어떻게 이해하셨는지 궁금합니다.
```