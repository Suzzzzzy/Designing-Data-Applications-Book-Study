# Chapter4 부호화와 발전
어떻게 스키마를 변경하고 예전 버전과 새로운 버전의 데이터와 코드가 공존하는 시스템을 어떻게 지원하는지.
다양한 데이터 부호화 형식의 데이터 저장과 통신에 어떻게 사용되는지.

## 발전
데이터 타입이나 스키마가 변경될 때 -> 애플리케이션 코드에 대한 변경도 발생
에전 버전의 코드와 새로운 버전의 코드 / 이전 데이터 타입과 새로운 데이터 타입 --> 공존 가능?
호환성을 유지해야한다!
- 하위 호환성: 새로운 코드는 예전 코드가 기록한 데이터 읽을 수 있어야 함
- 상위 호환성: 예전 코드는 새로운 코드가 기록한 데이터 읽을 수 있어야 함

## 데이터 부호화 형식
- 메모리에 객체, 구조체, 목록, 배열, 해시 테이블, 트리 등으로 데이터가 유지됨
- 이런 데이터 구조는 CPU에서 효율적으로 접근하고 조작할 수 있게 최적화됨

## JSON과 XML
1. JSON
- Javascript 객체 문법을 따르는 문자 기반의 데이터 포맷
- 문자열 형태로 존재하여 - 네트워크를 통해 전송할 때 유용
- 문자열과 수를 구분하지만 정수와 부동소수점 수를 구별하지 않음 -> 큰 수를 JS에서 파싱할때 부정확할 수 있음
- 유니코드 문자열(사람이 읽을 수 있는 텍스트) 잘 지원 but 이진 문자열을 지원하지 않는다
- 스키마 지원

2. XML
- 텍스트 형식
- 숫자로 구성된 문자열 구분할 수 없다
- 유니코드 문자열을 잘 지원한다 but 이진 문자열을 지원하지 않는다
- 스키마 지원

## 스리프트와 프로토콜 버퍼
- 스리프트와 프로토콜 버퍼는 같은 원리를 기반으로 한 이진 부호화 라이브러리
- 데이터를 위한 스키마 필요
- 스키마 정의를 사용해 코드를 생성하는 도구가 있다
- 필드 이름이 없는 대신 필드 태그를 포함 - 필드 이름의 절차 없이도 어떤 필드를 다루는지 알려주는 방법
- 프로토콜 버퍼는 각 필드에 required, optional 같은 표시가 있다

## 필드 태그와 스키마 발전 - 스리프트와 프로토콜 버퍼가 호환성을 유지하는 방법
- 필드에 새로운 태그 번호를 부여하는 방식으로 스키마에 새로운 필드 추가 가능
  - 예전 코드는 새로운 필드를 알지 못하기 때문에 새로생긴 필드를 무시할 수 있다 -> 상위호환
- 각 필드에 고유한 태그 번호가 있는 동안에는 태그 번호가 계속 같은 의미를 갖고 있기 때문에 새로운 코드가 예전 데이터를 항상 읽을 수 있음
  - 새로운 필드를 추가한 경우에 required 하면 안됨 -> 예전 코드는 추가한 새로운 필드를 기록하지 않기 때문 -> 따라서 기본값 or Optional
- 필드를 삭제하는 방법은 추가할때 호환성 문제를 해결하는 방식과 반대로 하면 됨
  - optional만 삭제 가능, 같은 태그 번호는 절대 다시 사용할 수 없음

## 아브로
- 부호화할 데이터 구조를 지정하기 위해 스키마 사용
- 2개의 스키마어: 사람이 편집할 수 있는 아브로 IDL / 기계가 더 쉽게 읽을 수 있는 JSON 기반 언어
- 스키마에 태그 번호가 없다
- 바이트열에는 필드나 데이터타입을 식별하기 위한 정보가 없다 -> 스키마를 이용해 각 필드의 데이터타입을 미리 파악해야 한다
- 필드에 Null을 허용하려면 유니온 타입을 사용해야 한다

## 쓰기 스키마
읽기는 특정 데이터를 부호화한 쓰기 스키마를 어떻게 알 수 있나?
1. 많은 레코드가 있는 대용량 파일 -> 파일의 시작부분에 한 번만 쓰기 스키마를 포함
2. 개별적으로 기록된 레코드를 가진 데이터베이스 -> 모든 부호화된 레코드의 시작 부분에 버전 번호를 포함하고 데이터베이스에는 스키마 버전 목록을 유지
3. 네트워크 연결을 통해 레코드 보내기 -> 네트워크 연결을 통해 통신할 때 연결 설정에서 스키마 버전 합의
- 스키마 버전을 사용하는 것은 매우 유용 -> 호환성 체크를 직접할 수 있기 때문

## 동적 생성 스키마에 친숙한 아브로 - 스키마에 태그가 포함되어 있지 않은 아브로
- 아브로는 관계형 스키마로부터 쉽게 생성 가능
- 데이터베이스 내용을 부호화하고 아브로 객체 컨테이너 파일로 모두 덤프 가능
- 각 데이터베이스 테이블에 맞게 레코드 스키마 생성 -> 각 칼럼은 해당 레코드의 필드, 칼럼 이름은 아브로의 필드이름에 매핑
- 데이터베이스 스키마가 변경될때: 새로운 아브로 스키마 생성 -> 새로운 아브로 스키마로 데이터 내보낸다
  - 필드는 이름으로 식별되기 때문에 갱신된 스키마는 이전 읽기 스키마와 매치 가능
- 스리프트나 프로토콜 버퍼는 필드 태그를 수동으로 할당해야 한다

# 서비스를 통한 데이터플로
- 예전 버전과 새로운 버전의 서버와 클라이언트가 동시에 실행되기를 기대하는 -> 서버와 클라이언트가 사용하는 데이터 부호화는 서비스 API의 버전간 호환이 가능해야 한다
  - 마이크로서비스 아키텍처의 핵심 설계 목표는 서비스를 배포와 변경에 독립적으로 만들어 애플리케이션 변경과 유지보수를 더 쉽게 할 수 있게 만드는것..!
- API는 표준화된 프로토콜과 데이터 타입으로 구성된다
- 여러가지 면에서 서비스는 데이터 베이스와 유사하다
  - 서비스는 클라이언트가 데이터를 제출하고 질의하는 것을 허용
  - 서비스는 비지니스 로직으로 미리 정해진 입력과 출력만 허용한 애플리케이션 특화 API를 공개

## 웹 서비스
- 웹 서비스: 서비스와 통신하기 위한 기본 프로토콜로, HTTP를 사용할 때 이를 웹 서비스라고 한다
- 웹 서비스에는 대중적인 방법인 REST 와 SOAP가 있다
1. REST
- 프로토콜이 아니라 HTTP의 원칙을 토대로 한 설계 철학
- 간단한 데이터 타입을 강조
- URL을 사용해 리소스를 식별
- 캐시 제어, 인증, 콘텐츠 유형 협상에 HTTP 기능 사용
- REST 원칙에 따라 설계된 API를 RESTful 이라고 한다

2. SOAP
- API 요청을 위한 XML 기반 프로토콜
- HTTP 상에서 일반적으로 사용되지만 HTTP와 독립적이며 대부분의 HTTP 기능을 사용하지 않는다
- 다양한 기능을 추가한 WS(웹 서비스 프레임워크)를 제공
- WSDL: SOAP 웹서비스에서 API가 사용하는 웹 서비스 기술 언어, XML 기반 언어

## RPC
REST와 RPC는 하나의 프로세스가 네트워크를 통해 다른 프로세스로 요청을 전송하고 가능한 빠른 응답을 기대하는 방식
- RPC: remote procedure call - 원격 프로시저 호출
- 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용 가능하게 해준다 -> 위치 투명성

### RPC 문제점
- 네트워크 요청은 예측이 어렵다 - 네트워크 문제로 요청과 응답이 유실되거나 원격 장비가 느려지거나 요청에 응답하지 않을 수 있다 -> 제어 불가
  - 네트워크 문제 함께 고려 필요 - 실패한 요청을 다시 보내는 것과 같은 대책을 세워야 한다

```
논의주제)
이번 챕터는 데이터 구조를 디스크 상에서나 네트워크에서 바이트열로 변환하는 방법에서 나아가 상하휘 호환성을 강조하고, 결국 더 나아가 아키텍처와 배포의 발전성에 대해 이야기하는 것 같았습니다.
상하위호환성에 대한 경험을 생각해보았을 때, 기존 컬럼은 변경하지 않고 새로운 컬럼을 추가하여 기본값을 null로 채우는 경험만 해보았던것 같습니다.
레거시 코드와, 새로운 작성하는 코드, 예전 데이터 스키마와 새로운 스키마.. 호환성을 고려했던 다른 분들의 개발 경험이 궁금합니다.
```