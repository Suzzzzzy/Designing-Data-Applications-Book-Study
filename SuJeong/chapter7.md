# 7. 트랜잭션 


## 1. 데이터 시스템의 여러 문제들
    - 데이터베이스 소프트웨어나 하드웨어의 실패 
    - 애플리케이션 다운
    - 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행하여 의도치 않은 내용 덮어씀  
    - 네트워크 끊김 
    - 클라이언트가 부분적으로만 갱신, 비정상적 데이터 read
    - 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그 유발

## 2. 트랜잭션
    - 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법
    - 트랜잭션은 전체가 성공(커밋) 하거나 실패(어보트, 롤백) 한다.

## 3. ACID 
    - 원자성(Atomicity)
        - 더 작은 부분으로 쪼갤 수 없는 무엇인가
        - 여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여 있는데 결함 때문에 완료(커밋)될 수 없다면 어보트되고 데이터베이스는 이 트랜잭션에서 지금까지 실행한 쓰기를 무시하거나 취소
        - 오류가 생겼을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력이 ACID 원자성의 결정적 특성 
        - 어보트 능력(abortability) 
    - 일관성(Consistency) 
        - 

    - 격리성(Isolation)
        - 클라이언트들이 데이터베이스의 동일한 레코드에 접근하면 동시성 문제(경쟁 조건)에 맞닥뜨리게 된다. 
        - 동시에 실행되는 트랜잭션은 서로 격리된다는 것 
        - 직렬성 격리는 성능 손해를 동반하므로 현실에서는 거의 사용되지 않음 
    - 지속성(Durability) 
        - 지속성은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장 

## 4. 단일 객체 연산과 다중 객체 연산
    - 다중 객체 트랜잭션은 흔히 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요 
    - 다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 함 
        -> 관계형 DB에서 이것은 전형적으로 클라이언트와 DB 서버 사이의 TCP 연결을 기반으로 한다. 
    

    - 비관계형 데이터베이스
        - 연산을 묶는 방법이 없는 경우가 많음
        - 다중 객체 API가 있더라도 (키-값 저장소는 한 연산 내에서 여러 키를 갱신하는 다중 put 연산도 있음) 트랜잭션 시멘틱이 아닐 수 있음 
        - 어떤 키에 대한 연산은 성공하고 나머지 키에 대한 연산은 실패해서 데이터베이스가 부분적으로 갱신된 상태가 될 수 있다. 

## 5. 단일 객체 쓰기
    - 원자성과 격리성은 단일 객체를 변경시에도 적용 
    - 저장소 엔진들은 거의 대부분 한 노드에 존재하는 단일 객체 수준에서 원자성과 격리성을 제공하는 것을 목표로 한다. 
    - 원자성은 장애복구(crash recovery) 용 로그를 써서 구현할 수 있고 격리성은 각 객체에 잠금을 사용해 구현 (동시에 한 스레드만 객체에 접근) 

## 6. 다중 객체 트랜잭션의 필요성
    - 원자성이 없으면 오류 처리가 훨씬 더 복잡해지고 격리성이 없으면 동시성 문제 발생 가능

## 7. 오류와 어보트 처리
    - 어보트의 취지 : 안전하게 재시도를 할 수 있게 하는 것 
    - 오류가 과부하 때문이라면 트랜잭션 재시도는 문제를 개선하는 게 아니라 악화시킬 수 있다. 
        -> 재시도 횟수 제한 또는 지수적 백오프 사용 또는 과부화와 관련된 오류를 다른 오류와 별도로 처리 할 것


## 8. 완화된 격리 수준
    - 두 트랜잭션이 동일한 데이터에 접근하지 않으면 서로 의존하지 않으므로 안전하게 병렬 실행될 수 있다. 
    - 동시성 문제(경쟁 조건)는 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 두 트랜잭션이 동시에 같은 데이터를 변경하려고 할 때만 나타난다.
    - 직렬성 격리는 데이터베이스가 여러 트랜잭션들이 직렬적으로 실행되는 것(동시성 없이 한 번에 트랜잭션 하나만 실행)과 동일한 결과가 나오도록 보장한다는 것을 의미 

## 9. 커밋 후 읽기
    - read committed : 가장 기본적인 수준의 트랜잭션 격리 
        - DB에서 읽을 때 커밋된 데이터만 보게 됨(더티 읽기 x)
        - DB에 쓸 때 커밋된 데이터만 덮어쓰기 됨(더티 쓰기 x) 
    - 일반적인 DB 의 기본설정이 많음 
    - 일반적인 방법으로 DB는 로우 수준 잠금을 사용해 더티 쓰기 방지 
    - 특정 객체 변경시 해당 객체에 대한 잠금 획득 -> 트랜잭션이 커밋되거나 어보트될 때 까지 잠금을 보유 -> 오직 한 트랜잭션만 어떤 주어진 객체에 대한 잠금 보유 
    - 읽기만 실행하는 트랜잭션들의 응답 시간을 느리게 만들 수 있다. 운용성이 나쁨 

    - 더티 읽기
        - 트랜잭션이 어보트되면 그때까지 쓴 내용은 롤백이 되는데 데이터베이스가 더티 읽기를 허용하면 트랜잭션이 나중에 롤백될 데이터를 읽게되는 문제가 발생한다.
    - 더티 쓰기
        - 먼저 쓴 내용이 아직 커밋되지 않은 트랜젝션에서 쓴 것이고 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어씀 
        - 보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 두 번째 쓰기를 지연시키는 방법 사용 

    

## 10. 스냅숏 격리와 반복 읽기
    - 백업, 분석 질의(대량)와 무결성 확인
    -> 스냅숏 격리를 통해 해결 
        -> 각 트랜잭션은 DB의 일관된 스냅숏으로부터 읽는다. (트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다) 
    - 스냅숏 격리는 백업이나 분석처럼 실행하는 데 오래 걸리며 읽기만 실행하는 질의에 요긴하다. 
    - 더티 쓰기 방지 위해 쓰기 잠금 사용함 

## 11. 일관된 스냅숏을 보는 가시성 규칙
    - 데이터베이스는 각 트랜잭션 시작 시 그 시점에 진행중인 모든 트랜잭션의 목록을 만들고 쓴 데이터는 모두 무시
    - 어보트된 트랜잭션이 쓴 데이터 모두 무시
    - 현재 트랜잭션이 시작한 후에 시작한 트랜잭션이 쓴 데이터는 그 트랜잭션의 커밋 여부에 관계 없이 모두 무시 


## 12. 갱신 손실 방지
    - 동시에 실행되는 쓰기 트랜잭션 사이에 발생할 수 있는 충돌 
    - 애플리케이션이 DB에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때 발생 가능
    - 두 트랜잭션이 이 작업을 동시에 하면 두 번째 쓰기 작업이 첫 번째 변경을 포함하지 않으므로 변경 중 하나는 손실될 수 있음 