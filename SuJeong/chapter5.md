# 5. 복제 

## 1. 복제 : 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본 유지

## 2. 복제의 필요성

1. 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간 감소
2. 시스템의 일부 장애 발생시 지속적으로 동작가능하게 하여 가용성 증가
3. 읽기 질의를 제공하는 장비의 수를 늘려 읽기 처리량 증가

## 3. 복제 데이터의 변경 시 대처
노드 간 변경 복제 알고리즘 : 단일 리더(single-leader), 다중 리더(multi-leader), 리더 없는 복제(leaderless)

## 4. 리더와 팔로워

복제 서버(reploca) : 데이터베이스의 복사본을 저장하는 각 노드

복제 서버에는 동일한 데이터를 유지해야 한다.

- 리더 기반 복제(leader-based replication) = (능동(active)/수동(passive), 마스터(master)/슬레이브 )
- 복제 서버 중 하나를 리더(leader = master = primary) 로 지정하고 클라이언트가 DB에 쓰기를 할 때 클라이언트는 요청을 리더에게 보내고 리더는 로컬 저장소에 새로운 데이터 기록
- 다른 복제 서버는 팔로워(follower = read replica 읽기 복제 서버, = 슬레이브 = 2차(secondary), 핫 대기(hot standby)
- 리더가 로컬 저장소에 새로운 데이터를 기록 → 데이터 변경을 복제 로그(repication log) 나 변경 스트림(change stream) 의 일부로 팔로워에게 전송)
- 각 팔로워가 리더로부터 로그를 받고 리더 처리 순서와 동일하게 모든 쓰기 적용, DB 로컬 복사본 갱신
- 클라이언트가 DB로부터 읽기를 할 때는 리더 또는 임의 팔로워에게 질의 가능, 쓰기는 리더에게만 허용된다. ( 팔로워는 클라이언트 관점에서 읽기 전용)
- 이 복제모드는 일반적인 관계형 DB에 내장되어 있음

## 5. 동기식 대 비동기식 복제

- 동기식 : 리더는 팔로워가 쓰기를 수신했는지 확인
  - 단점 : 동기 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없음 → 리더는 모든 쓰기를 차단하고 동기 복제 서버가 다시 사용할 수 있을 때까지 기다림
  - 모든 팔로워가 동기식인 상황은 비현실적 → 임의 한 노드의 장애는 전체 시스템을 멈추게 함
- 반동기식
  - 보통 팔로워 하나는 동기식으로 하고 그 밖에는 비동기식으로 하게 됨
  - 적어도 두 노드(리더, 하나의 팔로워) 에 데이터의 최신 복사본 존재
- 비동기식 : 리더는 메시지를 전송하지만 팔로워의 응답을 기다리진 않는다.
  - 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있다는 장점이 있다.
  - 내구성을 약화 하지만 지리적으로 DB 가 많이 분산 되었으면 또는 팔로워가 많다면 비동기식 복제를 널리 사용
- 좋은 성능과 가용성을 제공하면서 데이터 유실이 없는 복제 방법 연구 필요 (ex) 체인 복제)

## 6. 새로운 팔로워 설정

- 새로운 팔로워 추가시 리더의 데이터 복제본을 정확히 가지고 있는지 보장 필요
- 데이터는 항상 유동적이기 때문에
- 고가용성 보장 필요
- 팔로워 설정 프로세스
  - 가등하면 전체 데이터 베이스를 lock 하지 않고 ( 고가용성) 스냅숏을 특정 시점 기준으로 가져옴
  - 스냅숏을 새로운 팔로워 노드에 복사
  - 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청 (postgresql : 로그 일련번호 log sequence number, My SQL 에서는 이진로그 좌표 : binlog coordinate)
  - 팔로워가 스냅숏 이후 데이터 변경 미처리분을 모두 처리하면 리더를 따라잡게 됨 리더에서 발생하는 모든 변경사항 이어서 처리

## 7. 팔로워 장애 : 리더 따라잡기 복구

- 각 팔로워가 보관하고 있는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에서 꺼내서 망가진 팔로워를 복구할 수 있다.
- 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아내서 적용후 그 후는 리더에 연결해 팔로워 연결이 끊어진 동안 발생한 데이터 변경을 요청 → 데이터 변경 스트림을 계속 받으면서 진행하면 된다.

- 리더 장애: 장애 복구
- 팔로워 중 하나를 새로운 리더로 승격하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위한 설정 필요

- 장애복구(failover) 진행

#스플릿 브레인(split brain) : 두 노드가 모두 자신이 리더라고 생각하는 것

## 8. 복제 로그 구현

- 구문 기반 복제 : 리더는 모든 쓰기 요청 구문을 기록하고 쓰기를 실행 후 구문 로그를 팔로워에게 전송하며 팔로워는 SQL 구문을 파싱하고 실행한다.
  - 문제
    - NOW() 나 RAND() 와 같은 비결정적 함수를 호출하는 모든 구문은 각 복제 서버마다 다른 값 생성 가능성 존재 → 구문 기록시 리더가 모든 비결정적 함수 호출을 고정 값으로 반환하게끔 대처 가능 (현재 선호 x )
    - 자동 증가 컬럼은 복제 서버에서 정확히 같은 순서로 실행되어야 한다.
    - 부수 효과를 가진 구문은 부수 효과가 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수 효과가 발생할 수 있음
- 쓰기 전 로그 배송
  - 모든 쓰기는 로그에 기록
    - 로그 구조화 저장소 엔진의 경우 로그 자체가 저장소의 주요 부분 로그 세그먼트는 작게 유지, 백그라운드로 가비지 컬렉션
    - 개별 디스크 블록에 덮어쓰는 B트리의 경우 모든 변경은 쓰기 전 로그(write-ahead log)에 쓰기 때문에 고장 이후 일관성 있는 상태로 색인 복원 가능

- 논리적(로우 기반) 로그 복제
  - 복제 로그를 저장소 엔진 내부와 분리하기 위한 대안 하나는 복제와 저장소 엔진을 위해 다른 로그 형식 사용
- 트리거 기반 복제 (유연성)
  - 데이터의 서브셋만 복제하거나 데이터베이스를 다른 종류의 데이터베이스로 복제해야 하거나 충돌 해소 로직이 필요하면 복제를 애플리케이션 층으로 옮겨야 한다.
  - 트리거, 스토어드 프로시저, 오라클의 골든게이트 같은 도구를 사용한다.
  - 트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 함
  - 다른 방식보다 많은 오버헤드가 있음

## 9. 다중 리더 복제

리더 기반 복제의 단점은 리더가 하나만 존재하고 모든 쓰기는 해당 리더를 거쳐야 한다는 것