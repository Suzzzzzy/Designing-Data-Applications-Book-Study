# 4 - 1.부호화와 발전

## 1. 기초

- 변경 사항을 쉽게 적용할 수 있게 시스템 구축
- 관계형 데이터베이스는 특정 시점에는 정확하게 하나의 스키마가 적용된다.
- 스키마리스 (shcema-on-read, schemaless) 데이터 베이스는 스키마를 강요하지 않으므로 다른 시점에 쓰여진 이전 데이터 타입과 새로운 데이터 타입이 섞여 포함될 수 있음  →. 스키마 유연성

## 2. 주체에 따른 애플리케이션 새 버전 배포 방식

- 서버 측 애플리케이션 : 노드들에 새 버전 배포 → 새로운 버전 원할하게 실행 되면 점진적으로 모든 노드에 실행 (rolling upgrade, staged rollout)
- 클라이언트 측 애플리케이션 : 사용자에 의존

## 3. 예전버전, 새 버전이 공존하기 때문에 호환성 유지 필요

- 하위 호환성 : 새로운 코드는 예전 코드가 기록한 데이터를 Read 가능
- 상위 호환성 : 예전 코드는 새로운 코드가 기록한 데이터 Read 가능

## 4. 데이터 부호화를 위한 다양한 형식 종류

- JSON, XML, 프로토콜 버퍼(Protocol Buffers), 스리프트(Thrift), 아브로(Avro
- 중요 : 어떻게 스키마를 변경하고 예전버전과 새로운 버전의 데이터와 코드가 공존하는 시스템을 어떻게 지원하는지
- 웹 서비스 메시지 전달 시스템 : Representational State Transfet(Rest), 원격 프로시저 호출(remote procedure call) , 액테(actor), 메시지 큐

## 5. 데이터 부호화 형식

- 데이터 부호화가 필요한 이유 : 아래 두 표현 사이의 전환 필요 (인메모리 표현 → 바이트열)
- 메모리에 객체(object), 구조체(struct), 목록(list), 배열(array), 해시 테이블(hash table), 트리(tree) 등으로 데이터가 유지 → 데이터 구조가 CPU 에서 효율적으로 접근하고 조작할 수 있도록 최적화됨
- 데이터를 파일에 write, 네트워크 전송시 바이트열의 형태로 부호화 필요
  - 포인터 사용 불가
  - 따라서 메모리에서 사용하던 데이터 구조와 많이 달라지게 된다.

-> 이 전환을 부호화(직렬화 = 마샬링) 라고 함 (반대는 복호화(파싱, 역직렬화, 언마샬링)
- 프로그래밍 언어에서 인메모리 객체 → 바이트열로 부호화하는 기능 내장하고 있음
  ex) : Java : java.io.Serializable

- 인메모리 객체 저장, 복원가능
- 단점
  - 다른 프로그래밍 언어에서 데이터를 읽기 어려움 (통합의 어려움)
  - 자바의 내장 직렬화는 성능이 좋지 않음
  - 동일한 객체 유형의 데이터를 복원하기 위해 복호화 과정이 임의의 클래스를 인스턴스화 할 수 있어야 하는데 보안적으로 공격자가 임의의 바이트열을 복호화할 수 있게 되면 → 인스턴스를 할 수 있고 공격자가 원격으로 임의 코드 실행 가능하게 됨

## 6. Json 과 Xml
- 특징
  - 유니코드 문자열 지원함
- 단점
  - 수(number) 부호화
    - Josn 은 문자열과 수를 구분할 수 있지만 정수, 부동소수점등 정밀도를 정하기 어려움
  - 이진문자열(문자 부호화가 없는 바이트열) 지원하지 않음
    - 이진 데이터를 Base64를 사용해 텍스트로 부호화해 제한을 피한다.

## 7. 이진 부호화

- 이진 부호 : 어떤 값을 0과 1을 사용하여 나타내기 위한 부호 형식. 디지털 통신에 많이 사용됨

## 8. 스리프트와 프로토콜 버퍼

- 이진 부호화 라이브러리

- 필드의 데이터 타입 변경

  → 값변경 위험성 존재

- 부호화할 데이터를 위한 스키마 필요
  - 아파치 스리프트
    - 스리프트 인터페이스 정의 언어로 스키마 기술 필요
    - 바이너리프로토콜과 컴팩트프로토콜이라는 두가지 다른 이진 부호화 형식이 있음
    - 데이터 타입은 단일 값에서 다중 값으로 변화 허용하지 않고 중첩된 목록은 지원
  - 프로토콜 버퍼
    - 목록이나 배열 데이터타입이 없고 필드에 repeated 표시자(required, optional, repeated) 존재 → 레코드에 단순히 동일한 필드 태그가 여러 번 나타난다.
  - 아브로
    - 이진 부호화 형식
    - 하둡에 적용 가능
    - 부호화할 데이터 구조를 지정하기 위해 스키마 사용
      - 스키마 언어 : 아브로 IDL, JSON 기반 언어
      - 부호화는 단순히 연결된 값으로 구성
      - 데이터 파싱하기 위해 스키마에 나타난 순서대로 필드를 살펴보고 스키마를 이용해 각 필드의 데이터타입을 미리 파악
      - 데이터를 읽는 코드가 데이터를 기록한 코드와 정확히 같은 스키마를 사용하는 경우에만 이진 데이터를 올바르게 복호화 가능 (스키마 일치해야함)
- 필드 태그와 스키마 발전
  - 부호화된 레코드는 부호화된 필드의 연결일 뿐이다.
  - 각 필드는 태그 숫자로 식별하고 데이터 타입을 주석으로 단다.
  - 각 필드는 태그 숫자로 식별
  - 데이터 타입을 주석으로 단다.
  - 필드 값을 설정 하지 않는 경우 단순히 부호화 레코드에서 생략
  - 부호화된 데이터는 필드 이름을 전혀 참조하지 않음 스키마에서 필드이름 변경 가능
  - 필드 태그는 기존의 모든 부호화 된 데이터를 인식 불가능하게 만들 수 있기 때문에 변경할 수 없다.

#스키마 발전(schema evolution) : 스키마는 필연적으로 시간이 지남에 따라 변함


## 9. 쓰기 스키마와 읽기 스키마

- 읽기 스키마(reader’s schema) : 애플리케이션이 파일이나 데이터베이스 또는 네트워크로부터 수신 등으로 읽은 어떤 데이터를 복호화하길 원한다면 데이터가 특정 스키마로 복호화되어야 하고 이 스키마를 읽기 스키마라고 한다.  → 애플리케이션 코드는 이 스키마에 의존한다.

아브로의 핵심 아이디어 : 쓰기 스키마와 읽기 스키마가 동일하지 않아도됨 호환 가능하면 된다.

- 데이터를 읽는 코드가 읽기 스키마에는 없고 쓰기 스키마에 존재하는 필드는 무시
- 데이터를 읽는 코드가 기대하는 어떤 필드가 쓰기 스키마에는 포함돼 있지 않은 경우 읽기 스키마에 선언된 기본값으로 채움


## 10. 다양한 시점에 기록된 다양한 값

- 스키마 발전은 기본 저장소가 여러 가지 버전의 스키마로 부호화된 레코드를 포함하면서 → 전체 데이터베이스가 단일 스키마로 부호화된 것처럼 통일성있게 보이게 함


## 11. 보관 저장소

- 데이터 덤프 : 한번에 기록하고 변하지 않기 때문에 아브로 객체 컨테이너 파일과 같은 형식이 적합


## 12. 서비스를 통한 데이터플로: REST, RPC

- 네트워크 통신 프로세스 배치 방법
  - 클라이언트와 서버 역할 배치
  - (Service-oriented architecture SOA)  → 마이크로 서비스 설계(microservices architecture)
- 서비스 지향 및 마이크로 아키텍처 핵심 설계 목표 : 서비스를 배포와 변경에 독립적으로 만들어 애플리케이션 변경과 유지보수를 더 쉽게 할 수 있게 만드는 것


# 4 - 2. 분산 데이터

- 분산데이터의 필요성
  - 확장성 : 데이터 볼륨, 읽기 부하, 쓰기 부하가 단일 장비에서 다룰 수 있는 양보다 커지면 부하를 여러 장비로 분배 필요
  - 내결함성/고가용성 : 장비 하나(또는 여러 장비나 네트웤, 전체 데이터센터)가 죽으면 다른 장비를 사용해서 대비
  - 지연 시간
    - 사용자가 지리적으로 가까운곳의 서비스 이용 가능

- 고부하 확장 : 수직확장
  - 공유 메모리 접근 방식의 문제점은 비용이 빠르게 증가
  - 병목현상이 존재하여 꼭 많은 장비가 많은 처리를 보장하지 않음
  - 공유 디스크 아키텍처 : 독립적인 CPU와 RAM 을 탑재한 여러 장비를 사용하지만 데이터 저장은 장비 간 공유하는 디스크 배열에 함
  - 공유 메모리 아키텍처

- 비공유 아키텍처 : 수평확장, 규모 확장
  - 각장비 가상 장비를 노드라고 하며 CPU, RAM, 디스크를 독립적으로 사용