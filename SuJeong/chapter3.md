# 3. 저장소와 검색

## 1. 데이터 베이스의 두가지 작업

- 데이터 저장
- 데이터 제공

#특정 작업부하(workload) 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 대해 대략적인 개념을 이해할 필요가 있다.


## 2. 정리
- 관계형 데이터베이스
- NoSQL 저장소 엔진
- 
- 로그 구조(log-structured) 계열 저장소 엔진 (ex B tree)
- 페이지 지향(page-oriented) 계열 저장소 엔진

- 데이터 베이스는 내부적으로 추가 전용(append-only) 데이터 파일인 로그(log)를 사용한다.
- 데이터 베이스에서 특정 키의 값을 효율적으로 찾기 위해서 색인이 필요함
- 색인을 잘 선택했다면 읽기 질의 속도가 향상된다. 하지만 모든 색인은 쓰기 속도를 떨어뜨린다.
  - 읽기를 위해서 지정한 색인을 쓰기 시에 고려하여 데이터를 저장해야 하기 때문 

## 3. 저장소 엔진
- 트랜잭션 처리 최적화(OLTP)
- 분석 최적화(OLAP)

## 4. 색인

- 색인의 일반적인 개념은 부가적인 메타데이터를 유지
- 메타데이터는 이정표 역할을 하여 데이터의 위치를 찾는데 도움을 준다.
- 색인은 쓰기 속도를 느리게 한다 → 데이터를 쓸 때마다 매번 색인도 갱신해야 하기 때문
- → 트레이드 오프 : 색인을 잘 선택했다면 읽기 질의 속도가 향상되지만 쓰기 속도는 떨어뜨린다.

## 5. 종류
- 해시 색인
  - 키 - 값 사전타입과 유사 
  - 해시맵으로 구현 (보통의 경우)
  - 색인 전략 예시 : 키를 데이터 파일의 바이트 오프셋에 매핑해서 인메모리(DB는 일반적으로 DISK 에 저장, 인메모리에 저장하면 더 빠름) 해시 맵을 유지하는 전략
    - 바이트 오프셋 : 값을 바로 찾을 수 있는 위치
    - 파일에 새로운 키 - 값 쌍을 추가할 때마다 방금 기록한 데이터의 오프셋을 반영하기 위해 해시맵도 갱신해야 한다.
    - 값을 조회하려면 해시 맵을 사용해 데이터 파일에서 오프셋을 찾아 해당 위치를 구하고 값을 읽는다.
    - 파일에 새로운 키-값 쌍을 추가할 때마다 방금 기록한 데이터의 오프셋을 반영하기 위해 해시 맵도 갱신 필요
    - 비트 캐스크 (리악의 기본 저장소 엔진) : 해시 맵을 전부 메모리에 유지하기 때문에 사용 가능한 램에 모든 키가 저장되며 고성능 읽기, 쓰기 보장
      - 값은 한 번의 디스크 탐색으로 디스크에서 적재할 수 있기 때문에 사용 가능한 메모리보다 더 많은 공간 사용
      - 데이터 파일의 일부가 이미 파일 시스템 캐시에 있을때 디스크 입출력없이 바로 찾는것이 가능 
      - 각 키의 값이 자주 갱신되는 상황에서 매우 적합
  - 파일에 추가를 하며 디스크 공간이 부족한 상황 해결책 : 특정 크기의 세그먼트로 로그 나누기
  - 새그먼트 파일들을 컴팩션 가능 (compaction) → 로그에서 중복된 키 제거하고 각 키의 최신 갱신 값만 유지
  - 오래된 세그먼트 병합은 점점 조각화되는 데이터 파일 문제를 줄일 수 있다. 
    - 컴팩션 
      - 세그먼트는 쓰여진 다음에는 변경이 불가하기 때문에 병합할 세그먼트는 놓고 새로운 세그먼트 파일로 새로 만든다.
      - 컴팩션 수행 동안에는 old 세그먼트를 사용해 읽기, 쓰기 요청을 하다가 컴펙션이 완료되면 새로운 세그먼트를 사용하도록 하고 old 세그먼트 파일은 지워준다. 
      - 병합을 하여 세그먼트를 적게 유지하며 여러개의 해시 맵을 확인하지 않아도 된다. 
  - 해시 색인을 구현하면서 고려해야 하는 문제
    - 파일 형식 : 바이트 단위 문자열 길이 부호화 -> 원시 문자열 부호화( 바이너리 형식 ) 사용 
    - 레코드 삭제 : 키와 관련된 값 삭제 시 데이터 파일에 특수한 삭제 레코드 추가 필요 (툼스톤)
    - 고장 복구 : DB 재시작시 인메모리 해시맵은 디스크와 달리 손실된다. 세그먼트 파일이 크기가 클 때 해시 맵 복원이 오래 걸릴 수 있다. 
              따라서 비트캐스크를 사용하여
                  각  세그먼트 해시 맵을 메모리로 로딩하기 위해 스냅샷을 디스크에 저장하여 복구할때 시간을 줄일 수 있게 한다. 
    - 부분적 레코드 쓰기 
    - 동시성 제어 : 쓰기 동시성 제어시 하나의 쓰기 스레드를 사용하고 데이터 파일 세그먼트는 다중 스레드로 동시 읽기 가능하다. 
  - 단점
    - 해시 테이블은 메모리에 저장해야 하기 때문에 키가 너무 많으면 문제
    - 해시 충돌 방지 로직 필요
    - 범위 질의(range query)에 효과적이지 않다. 해시는 범위정렬이 효과적이지 않겠지..?

- SS 테이블
  - SS 테이블 : 정렬된 문자열 테이블(Sorted String Table) 키로 정렬된 형식
  - 각 키는 각 병합된 세그먼트 파일 내에 한개만 있어야함 (컴펙션 과정에서 이렇게 만듬)
  - 다중 세그먼트가 동일한 키를 포함한 경우 가장 최근 세그먼트의 값은 유지하고 오래된 세그먼트의 값을 버린다. 
  - 앞에서 봤던 해시 색인을 가진 로그 세그먼트보다 큰 장점들이 있다. 
    - 다중 세그먼트가 동일한 키 포함시 최근것만 유지
    - 세그먼트 병합을 하며 메모리보다 더 큰 파일이라도 가능 
    - 메모리에 모든 키의 색인을 유지할 필요가 없다. range 검색 가능 
  
- LSM 트리
  - LSM 트리는 각 컴팩션 단계에 있는 여러 가지 데이터 구조와 SS 테이블 확인 필요하기 때문에 읽기가 B tree 에 비해 느릴 수 있다.
  - LSM 저장소 엔진 : 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진 
  - 데이터베이스에 존재하지 않는 키를 찾을 경우 느릴 수 있음 
  
- 최적화
   - 불룸 필터(Bloom filter) : 저장소 엔진이 접근 최적화를 위해서 사용하는데 키가 데이터베이스에 존재하지 않음을 알려줌 
   - 압축, 병합 시기 결정 전략
     - 크기 계층 컴팩션
     - 레벨 컴팩션 

- B 트리 (B - tree)
  - 가장 널리 사용 되는 색인 구조
  - 키로 정렬된 키-값 쌍을 유지하기 때문에 키 - 값 검색과 범위 질의에 효과적
  - 전통적으로 4KB 이상 크기의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기
  - 각 페이지는 주소나 위치를 이용해 식별
  - 한 페이지는 B 트리의 Root(루트) 로 지정 → 색인에서 키를 찾으려면 루트에서 시작
  - 페이지는 여러 키와 하위 페이지의 참조를 포함
  - 각 하위 페이지는 키가 계속 이어지는 범위를 담당, 참조 사이의 키는 해당 범위 경계가 어디인지 나타냄
  - 최종적으로 개별 키 (리프 페이지 leaf page) 를 포함하는 페이지에 도달

    → 각 키의 값을 포함하거나 값을 찾을 수 있는 페이지의 참조 포함

  - B - tree 의 키의 값을 갱신하려면 키를 포함하고 있는 리프 페이지를 검색, 페이지의 값을 변경 → 페이지를 디스크에 다시 기록
  - B 트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어 쓰는 것
  - 데이터 복구를 위해 디스크 상에 쓰기 전 로그 (write-ahead log : WAL , redo log) 데이터 구조를 추가해 B tree 를 구현해야 함
    - 트리 페이지에 변경된 내용을 적용하기 전에 모든 B 트리의 변경 사항 기록하는 추가 전용 파일

- 트랜잭션 처리 및 분석 
  - 온라인 트랜잭션 처리(online transaction processling OLTP)
    - 질의당 적은 수의 레코드
    - 웹 애플리케이션 최종 사용자/소비자가 사용
    - 기가바이트, 테라바이트
  - 온라인 분석 처리(online analytic processing, OLAP)
    - 많은 레코드에 대한 집계 
    - 의사결정에 도움주는 데이터
    - 테라바이트, 페타바이트
  - 데이터 웨어 하우징 
    - 분석가들이 OLTP 에 영향을 주지 않고 (영향을 주지 않는 것이 정말 중요 서비스를 위해) 마음껏 질의할 수 있는 개별 DB 
    - OPTP 데이터 베이스 -> 추출 -> 분석 친화적 스키마로 변환 -> 데이터웨어하우스에 적재 = ETL(Extract-Transform-Load)
    - 장점 : 분석 접근 패턴에 맞게 최적화 가능 
  - 분석용 스키마 : 별모양 스키마, 눈꽃송이 모양 스키마
    - 분석에서 사용하는 스키마는 별 모양 스키마(차원 모델링) 이 정형화된 방식 
    - 별모양 스키마 : 테이블 관계가 시각화 될 때 사실 테이블이 가운데 있고 차원테이블이 둘러싸고 있는 모양 
    - 눈꽃송이 모양 스키마 : 차원이 하위 차원으로 더 세분화된다. 
    - 사실 테이블 / 차원 테이블 
    - 사실 테이블의 몇 컬럼은 차원테이블을 가리키는 외래키 참조
    - 사실 테이블의 각 로우는 이벤트를 나타냄
    - 차원 테이블은 이벤트의 속성 who, where, when, how why 등

- 컬럼 지향 저장소
  - 대부분 OLTP DB 저장소는 로우 지향 방식으로 데이터 배치한다.
  - 컬럼 지향 저장소란 모든 값을 하나의 로우에 함께 저장하지 않는 대신 각 칼럼별로 모든 값을 함께 저장 -> 질의에 사용되는 컬럼만 읽음 
  - 컬럼 지향 저장소 배치는 각 컬럼 파일에 포함된 로우가 모두 같은 순서임에 의존..? (id 있으면 좋지 않나?)
- 메모리 대역폭과 벡터화 처리
  - 수백만 로우 -> 데이터 웨어 하우스로 이동시 디스크로부터 메모리로 가져올때 대역폭이 병목
  - 메인 메모리 -> CPU 캐시 대역폭 효율적 사용 필요 
  - CPU 명령 처리 파이프라인에서 분기 예측 실패와 버블 피하고
  - 최신 CPU 에서 단일 명령 다중 데이터명령을 사용하게 해야함 
  - 벡터화 처리 : 비트 AND OR 등과 같은 연산자는 압축된 컬럼 데이터 덩어리를 바로 연산할 수 있게 설계 
  