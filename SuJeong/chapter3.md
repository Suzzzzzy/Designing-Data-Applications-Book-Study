# 3. 저장소와 검색

## 1. 데이터 베이스의 두가지 작업

- 데이터 저장
- 데이터 제공

#특정 작업부하(workload) 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 대해 대략적인 개념을 이해할 필요가 있다.


## 2. 정리
- 관계형 데이터베이스
- NoSQL 저장소 엔진
- 로그 구조(log-structured) 계열 저장소 엔진 (ex B tree)
- 페이지 지향(page-oriented) 계열 저장소 엔진

- 데이터 베이스는 내부적으로 추가 전용(append-only) 데이터 파일인 로그(log)를 사용한다.
- 데이터 베이스에서 특정 키의 값을 효율적으로 찾기 위해서 색인이 필요함
- 색인을 잘 선택했다면 읽기 질의 속도가 향상된다. 하지만 모든 색인은 쓰기 속도를 떨어뜨린다.

## 3. 저장소 엔진
- 트랜잭션 처리 최적화(OLTP)
- 분석 최적화(OLAP)

## 4. 색인

- 색인의 일반적인 개념은 부가적인 메타데이터를 유지
- 메타데이터는 이정표 역할을 하여 데이터의 위치를 찾는데 도움을 준다.
- 색인은 쓰기 속도를 느리게 한다 → 데이터를 쓸 때마다 매번 색인도 갱신해야 하기 때문
- → 트레이드 오프 : 색인을 잘 선택했다면 읽기 질의 속도가 향상되지만 쓰기 속도는 떨어뜨린다.

## 5. 종류
- 해시 색인
  - 색인 전략 예시 : 키를 데이터 파일의 바이트 오프셋에 매핑해서 인메모리 해시 맵을 유지하는 전략
    - 바이트 오프셋 : 값을 바로 찾을 수 있는 위치
    - 값을 조회하려면 해시 맵을 사용해 데이터 파일에서 오프셋을 찾아 해당 위치를 구하고 값을 읽는다.
    - 파일에 새로운 키-값 쌍을 추가할 때마다 방금 기록한 데이터의 오프셋을 반영하기 위해 해시 맵도 갱신 필요
    - 비트 캐스크 (리악의 기본 저장소 엔진) : 해시 맵을 전부 메모리에 유지하기 때문에 사용 가능한 램에 모든 키가 저장되며 고성능 읽기, 쓰기 보장
      - 값은 한 번의 디스크 탐색으로 디스크에서 적재할 수 있기 때문에 사용 가능한 메모리보다 더 많은 공간 사용
      - 각 키의 값이 자주 갱신되는 상황에서 매우 적합
  - 단점
    - 해시 테이블은 메모리에 저장해야 하기 때문에 키가 너무 많으면 문제
    - 해시 충돌 방지 로직 필요
    - 범위 질의(range query)에 효과적이지 않다.
  - 파일에 추가를 하며 디스크 공간이 부족한 상황 해결책 : 특정 크기의 세그먼드로 로그로 나누기
  - 새그먼트 파일들을 컴팩션 가능 (compaction) → 로그에서 중복된 키 제거하고 각 키의 최신 갱신 값만 유지

- SS 테이블
  - SS 테이블 : 정렬된 문자열 테이블(Sorted String Table) 키로 정렬된 형식
  
- LSM 트리
  - LSM 트리는 각 컴팩션 단계에 있는 여러 가지 데이터 구조와 SS 테이블 확인 필요하기 때문에 읽기가 B tree 에 비해 느릴 수 있다.
    
- B 트리 (B - tree)
  - 가장 널리 사용 되는 색인 구조
  - 키로 정렬된 키-값 쌍을 유지하기 때문에 키 - 값 검색과 범위 질의에 효과적
  - 전통적으로 4KB 이상 크기의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기
  - 각 페이지는 주소나 위치를 이용해 식별
  - 한 페이지는 B 트리의 Root(루트) 로 지정 → 색인에서 키를 찾으려면 루트에서 시작
  - 페이지는 여러 키와 하위 페이지의 참조를 포함
  - 각 하위 페이지는 키가 계속 이어지는 범위를 담당, 참조 사이의 키는 해당 범위 경계가 어디인지 나타냄
  - 최종적으로 개별 키 (리프 페이지 leaf page) 를 포함하는 페이지에 도달

    → 각 키의 값을 포함하거나 값을 찾을 수 있는 페이지의 참조 포함

  - B - tree 의 키의 값을 갱신하려면 키를 포함하고 있는 리프 페이지를 검색, 페이지의 값을 변경 → 페이지를 디스크에 다시 기록
  - B 트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어 쓰는 것
  - 데이터 복구를 위해 디스크 상에 쓰기 전 로그 (write-ahead log : WAL , redo log) 데이터 구조를 추가해 B tree 를 구현해야 함
    - 트리 페이지에 변경된 내용을 적용하기 전에 모든 B 트리의 변경 사항 기록하는 추가 전용 파일