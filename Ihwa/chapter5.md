# 05장. 복제

복제란?
네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지하는 것

데이터 복제가 필요한 이유  
- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다.
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

</br>

복제에서의 어려움은 복제된 데이터의 변경에 있다.  
노드 간 변경을 복제하기 위한 세가지 알고리즘
- 단일 리더 복제
- 다중 리더 복제
- 리더 없는 복제

</br>

### 리더와 팔로워  
데이터베이스의 복사본을 저장하는 각 노드를 복제서버라고 한다.

**가장 일반적인 문제**  
데이터베이스의 모든 쓰기는 복제 서버에서 처리되어야 한다.   
그렇지 않으면 복제 서버는 더 이상 동일한 데이터를 유지할 수 없다.  
-> 해결책은 **리더 기반 복제(능동/수동, 마스터 슬레이브 복제**라고도 함)이다.

복제 서버 중 하나를 리더(마스터나 프라이머리)라고 지정한다.
클라이언트가 데이터베이스에 쓰기를 할 때 클라이언트는 요청을 리더한테 보낸다.   
→ 리더는 로컬에 새로운 데이터를 기록한다.   
→ 리더는 복제 로그나 변경 스트림의 일부로 다른 복제 서버(팔로워, 읽기 복제 서버, 슬레이브, 2차, 핫 대기)에 데이터 변경을 전달한다.   
→ 슬레이브 서버는 리더와 동일하게 데이터 쓰기를 적용한다.

**클라이언트가 데이터베이스로부터 읽기를 할 때는 마스터든 슬레이브든 어디든 질의할 수 있다. 그러나 쓰기는 마스터에게만 허용되며 슬레이브 서버는 읽기 전용으로 사용된다.**

### 동기식 대 비동기식 복제  
복제 시스템의 중요한 세부사항으로 복제의 동기식 발생과 비동기식 발생이있다.  

동기식 발생
- 장점
팔로우가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장한다. 갑자기 리더가 작동하지 않아도 팔로워 데이터로만으로도 계속 사용할 수 있다는 확신이 있다.
- 단점
팔로워가 죽거나 네트워크 문제로 응답하지 않는다면 쓰기가 처리될 수 없다는 것이다. 리더는 모든 쓰기를 차단하고 동기 복제 서버가 다시 활성화될 때까지 기다려야 한다.
- 복제불가로 인해 쓰기가 중단되는 상황은 되게 별로다. 현실적으로 데이터베이스에서 동기식 복제를 사용하려면 하나의 팔로워는 동기식으로, 이 외의 팔로워는 비동기로 하는 것을 의미한다. 이는 적어도 두 노드 이상의 복제가 실행된다는 것이다. 이런 설정을 **반동기식**이라고 한다.

비동기식 발생

- 장점
동기식 발생과 반대로 팔로워에 문제가 생긴다해도 리더에서의 쓰기는 계속 처리할 수 있다.
- 단점
리더가 잘못되어 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실된다. 이는 클라이언트에서 쓰기가 확인되었어도 팔로워에서 조회가 불가능하므로 지속성을 보장할 수 없다는 의미이다.
- 일반적으로 리더 기반 복제는 완전히 비동기식으로 구성한다.

</br>

### 새로운 팔로워 설정

복제 서버 수를 늘리거나 장애 노드의 대체를 위해 새로운 팔로워 설정이 필요할 때가 있다. 새로운 팔로워가 리더의 데이터 복제본을 정확히 갖고있는지 어떻게 보장할 수 있을까?

 1. 가능하다면 전체 데이터베이스를 잠그지 않고 리더의 데이터베이스 스냅숏을 일정 시점에 가져온다. 대부분의 데이터베이스는 백업이 필요하기 때문에 이 기능을 갖췄다.

1. 스냅숏을 새로운 팔로워 노드에 복사한다.
2. 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청한다. 이는 스냅숏이 리더의 복제 로그의 정확한 위치와 연관돼야 한다. 이 위치의 명칭은 다양하다. (PostgreSQL-로그 일련번호 / MySQL-이진로그 좌표)
3. 팔로워가 스냅숏 이후 데이터 변경의 미처리분을 모두 처리했을 때 따라잡았다고 말한다. 이제부터 리더에 발생하는 데이터 변화를 이어 처리할 수 있다.

</br>

### 노드 중단 처리
시스템의 모든 노드는 예기치 않게 중단될 수도 있지만 계획된 유지보수로 인해 중단될 수도 있다. 중단시간 없이 개별 노드를 재부팅 할 수 있다는 점은 운영과 유지보수에 큰 장점이다.  
리더기반 복제에서 고가용성은 어떻게 달성할 수 있을까?

**파로워 장애:따라잡기 복구**

각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관  
보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아낸다.  
→ 팔로워는 리더에 연결해 팔로워 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청할 수 있다.  
→ 이 변경이 다 적용되면 리더를 다 따라잡게 되고 이전과 같이 데이터 변경 스트림을 계속 받을 수 있다.

**리더장애: 장애 복구**

팔로워 중 하나를 새로운 리더로 승격해야 하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하며 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다. → **장애 복구**

</br>

장애 복구 구성  
1. 리더가 장애인지 판단 : 대부분은 타임아웃을 사용
2. 새로운 리더를 선택 : 선출 과정을 통해 이뤄지거나 제어노드에 의해 임명될 수 있다.
3. 새로운 리더 사용을 위해 시스템 재설정 : 클라이언트는 새로운 쓰기 요청을 새로운 리더에게 보내야 하며 이전 리더가 돌아오면 새로운 리더를 인식할 수 있게끔 해야한다.

위 과정 중 잘못될 수 있는 것  
- 비동기식 복제일 경우 이전 리더가 실패하기 전에 쓰기 일부를 수신하지 못할 수 이ㅆ으며 이는 내구성에 대한 클라이언트의 기대를 져버리게 된다.
- 쓰기를 폐기하는 방법은 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정돼야 한다면 특히 위험하다. 데이터베이스 내 자동 증가 카운터를 기본키로 할당한다면 새로운 리더와 이전 리더의 불일치로 인해 외부 데이터베이스 내의 데이터마저 같이 꼬일 수 있다.
- 특정 결함 시나리오에서 두 노드가 모두 자신이 리더라고 믿을 수 있다. (**스플릿 브레인**) 두 리더가 쓰기를 받으면서 충돌을 해서하는 과정을 거치지 않으면 데이터가 유실되거나 오염된다.
- 리더가 분명히 죽었다고 판단 가능한 **적절한 타임아웃**을 알 수 있나? 긴 타임아웃은 리더가 작동하지 않을 때부터 복구 시간까지 오랜 시간이 소요된다. 하지만 타임아웃이 너무 짧으면 불필요한 장애 복구가 있을 수 있다.

노드장애, 불안정한 네트워크, 복제 서버 일관성과 관련된 트레이드오프, 지속성, 가용성, 지연 시간등의 문제는 사실 분산 시스템에서 발생하는 근본적인 문제다. → 이는 추후에 더 자세히 알아볼 것

<br/>

### 복제 로그 구현 
리더는 모든 쓰기 요청(구문)을 기록하고 쓰고 다음 구문 로그를 팔로워에게 전송한다. 이 접근법은 합리적인 것 같지만 복제가 깨질 수 있는 다양한 사례가 있다.

- 현자 날짜와 시간을 얻기 위한 `NOW()` 나 임의의 숫자를 얻기 위한 `RAND()` 같은 비결정적 함수를 호출하는 모든 구문은 각 복제 서버마다 다른 값을 생성할 가능성이 있다.
- 자동증가 칼럼을 사용하는 구문이나 데이터베이스를 의존한다면 구문은 각 복제 서버에서 정확히 같은 순서로 실행되어야 한다.
- 부수 효과를 가진 구문(트리거, 스토어드 프로시저, 사용자 정의 함수)는 부수 효과가 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수효과가 발생할 수 있다.

</br>

**쓰기 전 로그 배송**

일반적으로 모든 쓰기는 로그에 기록한다는 사실을 확인했었다. 

- 로그 구조화 저장소 엔진
- B 트리

두 경우 모두 로그는 데이터베이스의 모든 쓰기를 포함하는 추가 전용 바이트 열이다. 완전히 동일한 로그를 사용해 다른 노드에서 복제 서버를 구축할 수 있다. 리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 전송하기도 한다.  
가장 큰 단점은 로그가 제일 저수준의 데이터를 기술한다는 점이다. WAL은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세 정보를 포함한다. 이렇게하면 복제가 저장소 엔진과 밀접하게 엮인다. 

</br>

**논리적(로우 기반) 로그 복제**  
복제 로그를 저장소 엔진 내부와 분리하기 위한 대안   
→ 복제와 저장소 엔진을 위해 다른 로그 형식을 사용하는 것  
이 같은 종류의 복제 로그를 저장소 엔진의 (물리적) 데이터 표현과 구별하기 위해 **논리적 로그**라고 부른다.   
관계형 데이터베이스용 논리적 로근느 대게 로우 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드 열이다.

- 삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함한다.
- 삭제된 로우의 로그는 로우를 고유하게 실별하는 데 필요한 정보를 포함한다. → 보통은 기본키이지만 기본키가 없다면 모든 칼럼의 예전 값을 로깅해야 한다.
- 갱신된 로우의 로그는 로우를 고유하게 실별하는 데 필요한 정보와 모든 칼럼의 새로운 값을 포함한다.

논리적 로그를 저장소 엔진 내부와 분리했기 때문에 하위 호환성을 더 쉽게 유지할 수 있고 리더와 팔로워에서 다른 버전의 데이터베이스 소프트웨어나 심지어 다른 저장소 엔진을 실행할 수 있다. 

</br>

**트리거 기반 복제**

트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 한다. 이 애플리케이션 코든느 데이터 베이스 시스템에서 데이터가 변경되면 자동으로 실행된다.  
트리거는 데이터 변경을 분리된 테이블에 로깅할 수 있는 기회를 가진다. 이 테이블로부터 데이터 변경을 외부 프로세스가 읽을 수 있다. 그러면 외부 프로세스는 필요한 애플리케이션 로직을 적용해 다른 시스템으로 데이터 변경을 복제한다.

</br>

### 복제 지연 문제

복제는 내결함성 뿐만이 아닌 확장성과 지연시간의 이유로도 필요하다.  
읽기 확장 아키텍처에서는 간단히 팔로워를 더 추가함으로써 읽기 전용 요청을 처리하기 위한 용량을 늘릴 수 있다.  
비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤처진다면 지난 정보를 볼 수도 있다. 이 상황은 데이터베이스에 명백하게 불일치가 발생한다.

**논의 주제**  
실무에서 데이터 복제에 대해 경험해본 적이 있으신가요??