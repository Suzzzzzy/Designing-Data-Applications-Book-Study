# 1장. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

**오늘날의 애플리케이션 : 데이터 중심**  
- CPU 성능은 애플리케이션을 제한하는 요소 x
- 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도가 중요

</br>

**데이터 중심 애플리케이션이 공통으로 필요로 하는 기능** 
- 데이터베이스 (데이터 저장)
- 캐시 (읽기 속도 향상)
- 검색 색인 (데이터 검색 필터링 제공)
- 스트림 처리 (비동기 처리)
- 일괄 처리 (주기적인 대량의 누적 데이터 분석)

</br>

**데이터 시스템**  
- 데이터베이스, 메시지 큐, 캐시 등
    - 매우 다른 접근 패턴을 갖고 있어 서로 다른 성능 특성을 갖고 있으나 데이터 시스템이라고 포괄적으로 부른다.
- 분류 간 경계가 흐려지고 있다.
- 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없다.
    - 많은 애플리케이션은 과도하고 광범위한 요구사항을 가지기 때문이다.
    - 복합 데이터 시스템으로 설계
- 작업은 단일 도구에서 효율적으로 수행할 수 있는 `태스크`로 나누고 다양한 도구들은 애플리케이션 코드를 이용해 서로 연결한다.


<aside>
💡 개발자 → 애플리케이션 개발자면서 데이터 시스템 설계자이다.
</aside>

</br>

**유용한 애플리케이션이 되기 위한 요구사항**  
- 기능적 요구사항
    - 여러 방법으로 데이터를 저장 / 조회 /검색 / 처리하는 작업
- 비기능적 요구사항
    - 보안, 신뢰성, 법규 준수, 확장성, 호환성, 유지보수성과 같은 일반 속성

</br>

## 신뢰성

- `결함`이 발생해도 시스템이 올바르게 동작하게 만든다.
- 소프트웨어에 대한 일반적인 기대 
⇒ “무언가 잘못되더라도 지속적으로 올바르게 동작함”에 대한 기대
- 애플리케이션은 사용자가 기대한 기능을 수행한다.
- 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다.
- 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.
- 시스템은 허가되지 않은 접근과 오남용을 방지한다.

### **결함**

- 결함을 예측하고 대처할 수 있는 시스템 ⇒  `내결함성 or 탄력성을 지녔다.`라고 표현
    - 내결함성 : 시스템이 하드웨어 또는 소프트웨어의 오류, 장애 또는 고장에도 계속해서 정상적으로 동작하는 능력을 의미
    - 고가용성 : 시스템이 항상 사용 가능하고 중단되지 않는 상태를 유지하는 능력
    - 탄력성 : 용량 요구사항에 대해 신경쓰지 않고 자동화된 확장 및 축소
    - 내결함성, 고가용성, 탄력성
        
        [고가용성, 내결함성, 탄력성](https://goodlucknua.tistory.com/100)        
- 결함은 장애와 동일하지 않다.
    - *결함 : 사양에서 벗어난 시스템의 한 구성 요소*
    - 장애 : 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우
- 결함 확률을 0으로 줄이는 것은 불가능하다.
    - 결함으로 인한 장애가 발생하지 않게끔 내결함성 구조를 설계하는 것이 좋다.
- 실제로 많은 중대한 버그는 미흡한 오류 처리에 기인한다.

해결책 뿐만 아닌 예방책이 필요한 이유  
→ 공격자가 시스템을 손상시키고 민감한 데이터에 대한 접근 권한을 얻게되는 경우 수습 불가

</br>

### 하드웨어 결함
**시스템 장애율을 줄이기 위한 대응 :** 하드웨어 구성요소에 중복 추가  
- 디스크 RAID 구성 / 서버-이중전원 디바이스, hot-swap CPU / 데이터센터-예비 전원
- 구성요소 하나가 죽으면 고장 난 구성요소가 교체되는 동안 중복된 구성 요소를 대신 사용할 수 있다.
- 데이터 양과 애플리케이션의 계산 요구가 늘어나면서 더 많은 애플리케이션이 많은 수의 장비를 사용 → 하드웨어 결함율 증가
    - AWS와 같은 클라우드 플랫폼 - 단일 장비 신뢰성보다 유연성과 탄력성을우선으로 처리하게끔 설계되어 있다.
- 전체 장비의 손실을 견딜 수 있는 시스템으로 옮겨가는 중 → 운영상 장점이 있음
- 장비 재부팅 시 시스템 중단시간 필요 없이 한번에 한 노드씩 패치 가능

</br>

### **소프트웨어 오류**
시스템 내 체계적 오류  
-> 예상하기 더 어렵고 `노드간 상관관계` 때문에 시스템 오류를 더욱 많이 유발하는 경향이 있다.
- 잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그
- CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스
- 시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 케이스
- 한 구성 요소의 작은 결함이 다른 구성요소의 결함을 야기하고 차례차례 더 많은 결함이 발생하는 연쇄 장애

</br>

이 같은 소프트웨어 오류 문제는 아래와 같은 작은 일들이 문제 해결에 도움을 줄 수 있다.
- 시스템의 가정과 상호작용에 대해 주의 깊게 생각하기.
- 빈틈업는 테스트
- 프로세스 격리
- 죽은 프로세스의 재시작 허용
- 프로덕션 환경에서 시스템 동작의 측정, 모니터링, 분석하기

</br>

### **인적 오류**
*사람은 미덥지 않다.*  
- 오류의 가능성을 최소화하는 방향의 시스템 설계
    - 잘 설계된 추상화, API, 관리 인터페이스
- 실제 데이터를 사용하여 안전하게 테스트해 볼 수 있는 stage환경 제공
- 단위테스트 ~ 전체 시스템 통합 테스트, 수동 테스트까지 모든 수준의 테스트 진행
    - 정상적인 동작에서는 거의 발생하지 않는 코너 케이스를 다루는 데 유용하다.
- 장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르고 쉽게 복구할 수 있게 하라.
- 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 마련하라.
    - 모니터링 == 원격 측정
    - 조기에 경고 신호를 보내줄 수 있고 특정 가정이나 제한을 벗어나는지 확인할 수 있게 한다.
    - 문제 발생 시 지표는 문제를 분석하는데 매우 중요하다.
- 조작 교육과 실습을 시행
- *중요하지 않은 애플리케이션도 사용자에 대한 책임이 있다.*

</br>

## 확장성
- 부하가 증가해도 좋은 성능을 유지하기 위한 전략
- **시스템이 현재 안정적으로 동작한다고 해서 미래에도 안정적으로 동작한다는 보장은 없다.**
    - 성능 저하를 유발하는 흔한 이유 중 하나는 `부하증가`다.
- 확장성을 논하는 방법
    - 시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?
    - 추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?

</br>

**부하 매개변수(load parameter)** : 부하를 숫자로 기술할 수 있음

- 웹 서버의 초당 요청 수
- 데이터베이스의 읽기 대 쓰기 비율
- 대화방의 동시 활성 사용자
- 캐시 적중율 등,,

</br>

### **성능 기술하기**

부하 증가 시 일어나는 일 조사 방향 : **수치값 필요**  
- 부하 매개변수를 증가시키고 시스템 자원(CPU, 메모리, 네트워크 대역폭 등)은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
- 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?

</br>

시스템에 따라 **`부하 기준`**은 다를 수 있다.
- 하둡같은 일괄 처리 시스템 → `처리량`
- 온라인 시스템 → `응답시간`
- **지연 시간과 응답 시간**
    - 응답 시간 : 클라이언트 관점에서 본 시간으로 네트워크 지연과 큐 지연도 포함
    - 지연 시간 : 요청이 처리되길 기다리는 시간

</br>

클라이언트가 몇 번이고 반복해서 동일한 요청을 하더라도 매번 응답시간이 다르다. 
- 응답시간은 단일 숫자가 아니라 `측정 가능한 값의 분포`로 생각해야 한다.
- 분포 상의 `특이값` 이 있을 수 있다.
    - 백그라운드 프로세스의 컨텍스트 스위치, 네트워크 패킷 손실과 TCP 재전송, 가비지 컬렉션 휴지, 디스크에서 읽기를 강제하는 페이지 폴트, 서버 랙의 기계적인 진동이나 다른 여러 원인으로 추가 지연이 생길 수 있다.
- 전형적인 응답 시간을 알고싶다면 평균보다는 백분위를 사용하는 편이 좋다.
→ 응답시간 목록을 가지고 가장 빠른 시간부터 제일 느린 시간까지 정렬하면 중간 지점이 중앙값이 된다. 
→ 중앙값은 단일 요청을 참고한다.

</br>

### **부하 대응 접근 방식**

**확장과 관련한 언어**
- 용량 확장(scaling up, 수직 확장) : 기 존서버를 보다 높은 사양으로 업그레이드
- 규모 확장(scaling out, 수평 확장) : 장비를 추가하여 확장
- Auto Scaling(AWS와 같은 일부 클라우드 플랫폼) : 부하 증가 감지 시 컴퓨팅 자원 자동 추가(탄력적)
- 다수의 낮은 사양 장비의 부하분산 (비공유 아키텍처)

</br>

범용적이고 모든 상황에 맞는 확장 아키텍처는 없으며
아래와 같은 **아키텍처를 결정하는 요소**를 고려하여 구축해야 한다.
- 읽기의 양
- 쓰기의 양
- 저장할 데이터의 양
- 데이터의 복잡도
- 접근 패턴

</br>

## 유지보수성

본질 → 시스템에서 작업하는 엔지니어와 운영팀의 삶의 개선
- 유지보수의 종류
→ 버그 수정, 시스템 운영 유지, 장애 조사, 새로운 플랫폼 적응, 
     새 사용 사례를 위한 변경, 기술 채무 상환, 새로운 기능 추가 등

</br>

**소프트웨어 시스템 설계 원칙**
- 운용성
운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라.
- 단순성
시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라.
(사용자 인터페이스와는 별개)
- 발전성
엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라. 그래야 요구사항 변경같은 예기치 않은 사용 사례를 적용하기가 쉽다. (속성- 유연성, 수정 가능성, 적응성)

</br>

### 운용성 : 운영의 편리함 만들기
> 좋은 운영은 종종 나쁜 소프트웨어의 제약을 피하는 대안이 될 수 있다. 하지만 좋은 소프트웨어라도 나쁘게 운영할 경우 작동을 신뢰할 수 없다.
> 

</br>

**좋은 운영팀의 책임**
- 시스템 상태를 모니터링하고 상태가 좋지 않다면 빠르게 서비스를 복원
- 시스템 장애, 성능 저하 등의 문제의 원인을 추적
- 보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지
- 다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사항을 손상을 입히기 전에 차단
- 미래에 발생 가능한 문제를 예측해서 다른 플랫폼으로 이동하는 등 복잡한 유지보수 태스크를 수행
- 설정 변경으로 생기는 시스템 보안 유지보수
- 예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의
- 개인 인사 이동에도 시스템에 대한 조직의 지식 보존

</br>

**좋은 운영 : 동일하게 반복되는 태스크를 쉽게 수행하게끔 만드는 것**
- 좋은 모니터링으로 런타임 동작과 시스템의 내부에 대한 가시성 제공
- 표준 도구를 이용해 자동화와 통합을 위한 우수한 자원 제공
- 개별 장비 의존성을 회피
    - 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속해서 운영 가능해야 함.
- 좋은 문서와 이해하기 쉬운 운영 모델 제공
- 만족할 만한 기본 동작을 제공하고, 필요할 때 기본값을 다시 정의할 수 있는 자유를 관리자에게 부여
- 적절하게 자기 회복이 가능할 뿐 아니라 필요에 따라 관리자가 상태를 수동으로 제어할 수 있게 함
- 예측이 가능하게 하고 예기치 않은 상황을 최소화함

</br>

### 단순성: 복잡도 관리
**단순성이 구축하려는 시스템의 핵심 목표여야 한다.**
복잡도는 같은 시스템에서 작업해야 하는 모든 사람의 진행을 느리게 하고 나아가 유지보수 비용이 증가한다. : 

 **복잡도의 증상**

- 상태 공간의 급증
- 모듈 간 강한 커플링
- 복잡한 의존성
- 일관성 없는 명명과 용어
- 성능 문제 해결을 목표로 한 해킹
- 임시방편으로 문제를 해결한 특수 사례

</br>

우발적 복잡도를 줄이기 위한 최상의 도구 ⇒ `추상화` 

**좋은 추상화란?**
- **깔끔하고 직관적인 외관** 아래로 많은 세부 구현을 숨길 수 있다. 
- 재사용이 가능한 효율 뿐 아니라 고품질 소프트웨어로 이어진다.

</br>

### 발전성 : 변화를 쉽게 만들기

- 시스템의 요구사항은 끊임없이 변할 가능성이 크다.  
- 조직 프로세스 측면에서 `애자일 작업 패턴`은 변화에 적응하기 위한 프레임워크를 제공한다.
    - 테스트 주도 개발
    - 리팩토링