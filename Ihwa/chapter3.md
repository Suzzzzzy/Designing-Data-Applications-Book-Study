# 3장 저장소와 검색

## 색인
- 데이터베이스의 특정 키 값을 효율적으로 찾기 위한 데이터 구조
- 어떤 부가적인 `메타데이터`를 유지하는 것.
- 기본 데이터에서 파생된 추가적인 구조
- 색인 작업은 데이터베이스의 내용에는 영향을 미치지 않음
- 쓰기 성능에 영향을 줌
    - 데이터를 쓸 때마다 매번 색인도 갱신해야되기 때문
- 보통 자동으로 색인하지 않으며 개발자나 db관리자가 애플리케이션의 전형적인 질의 패턴에 대한 지식을 활용해 수동으로 색인을 선택
- 색인을 잘 선택했다면 읽기 질의 속도 향상 → 모든 쓰기 속도는 감소


## 해시 색인
- 키-값 데이터 색인
- 프로그래밍 언어에서 볼 수 있는 **사전 타입**과 매우 유사
- 보통 **해시맵(hash table)**로 구현
- 특정 크기의 세그먼트로 로그를 나누는 방식
- 특정 크기에 도달하면 세그먼트 파일을 닫고 새로운 세그먼트 파일에 이후 쓰기를 수행
- 세그먼트 파일들에 대해 `컴팩션`을 수행할 수 있다.

</br>

**컴팩션과 세그먼트 병합**
- **컴팩션** → 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것
    - 세그먼트를 더 작게 만듦
- 세그먼트가 쓰여진 후에는 절대 변경할 수 없기 때문에 병합 시에는 새로운 파일로 씀 → 전환 후 이전 세그먼트 파일은 삭제된다.
- 고정된 세그먼트의 병합과 컴팩션은 백그라운드 스레드에서 수행 가능
- 각 세그먼트는 키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 갖는다.

</br>

**실제 구현 시 주의해야 할 점**

- 파일 형식
    - 바이너리 형식을 사용하는 것이 더 빠르고 간단
- 레코드 삭제
    - 키에 해당하는 값을 삭제하려면 데이터 파일에 특수한 삭제 레코드를 추가해야함
- 고장(crash) 복구
    - 데이터베이스가 재시작되면 인메모리 해시맵은 손실
    - 데이터가 커지면 해시맵을 복원한느데 오래걸리기때문에 스냅샷을 만들어 디스크에 저장하여 복구 속도를 높임
- 부분적으로 레코드 쓰기
    - 데이터베이스에서 로그에 레코드를 추가하는 도중에 죽을 수 있음
    - 비트캐스크는 로그의 손상 부분을 탐지해 처리
- 동시성 제어
    - 순차적으로 로그에 추가할 때 일반적인 구현 방법은 싱글 스레드만 사용 가능
    - 읽기는 불변이므로 멀티 스레드로 동시 수행이 가능

</br>

**해시테이블의 제한사항**
- 메모리에 저장해야 하므로 키가 너무 많으면 문제가 된다. 
디스크 해시 맵을 유지한다 해도 아래와 같은 문제가 있다.
    - 무작위 접근 I/O가 많이 필요하다.
    - 디스크가 가득 찼을 때 확장하는 비용이 비싸다.
    - 해시 충돌 해소를 위한 성가신 로직이 필요하다.
- 해시맵은 범위 질의에 효율적이지 않다.

## SS(Sorted String Table)테이블과 LSM트리

- 키로 정렬된 형식 : 정렬된 문자열 테이블 or SS테이블이라 부름
- 키는 각 병합된 세그먼트 파일 내에 **한 번만** 나타나야 함
→ 컴팩션 과정은 이를 보장
- 쓰기가 들어오면 **인메모리 균형 트리(멤테이블)** 데이터 구조에 추가
- 멤테이블이 보통 수 메가바이트 정도의 임곗값보다 커지면 SS테이블 파일로 디스크에 기록한다.
- 새로운 SS테이블 파일은 데이터베이스의 가장 최신 세그먼트가 된다.
    - SS테이블을 디스크에 기록하는 동안 쓰기는 새로운 멤테이블 인스턴스에 기록
- 읽기 요청 제공을 위해 키를 찾는 순서
    - 멤테이블 → 가장 최신 세그먼트 → 두번째 오래된 세그먼트 → 세번째 오래된 세그먼트…
- 가끔 세그먼트 파일을 합치고 덮어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 과정을 백그라운드에서 수행한다.
- 그러나 동작 와중 데이터베이스가 고장나면 아직 디스크로 기록되지 않고 멤테이블에 가장 최신 쓰기는 손실된다. → 매번 쓰기를 즉시 추가할 수 있게 분리된 로그를 디스크 상에 유지해야 한다.

</br>

**SS테이블에서 LSM트리 만들기** 
- 로그 구조화 병합 트리(LSM : Log-Structured Merge-Tree)
- 백그라운드에서 연쇄적으로 SS테이블을 지속적으로 병합하는 것
- 데이터셋이 가능한 메모리보다 훨씬 더 크더라도 효과적
- 데이터가 정렬된 순서로 저장돼 있다면 범위 질의를 효율적으로 실행할 수 있음
- LSM저장소 엔진 : 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진
- LSM 트리 알고리즘의 경우 데이터베이스에 실재 존재하지 않는 키를 찾느 ㄴ경우 느릴 수 있다. → 멤테이블 부터 가장 오래된 세그먼트까지 거슬러 올라가야 하기 때문
- 이런 종류의 접근을 최적화하기 위해 저장소 엔진은 보통 블룸 필터를 추가적으로 사용
- SS테이블을 압축하고 병합하는 순서와 시기를 결정하는 다양한 전략
    - 크기 계층 : 상대적 새롭고 작은 SS테이블을 오래되고 큰 SS테이블에 병합
    - 레벨 컴팩션 : 키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 레벨로 이동

## B 트리

- 대부분의 관계형 데이터베이스에서 표준 색인 구현으로 B-트리를 사용할 뿐 아니라 많은 비관계형 데이터베이스에서도 사용
- 키로 정렬된 키-값 쌍을 유지
    - 때문에 검색과 범위 질의에 효율적
- 전통적으로 4KB 크기의 고정크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 함
- 한 페이지는 B트리의 루트로 지정
    - 페이지는 여러 키와 하위 페이지의 참조를 포함
    - 하위 페이지는 계속 이어지는 범위를 담당하고 참조 사이의 키는 해당 범위 경계가 어디인지 나타낸다.


**B-트리 알고리즘** 
- 이 알고리즘은 트리가 계속 **균형**을 유지하는 것을 보장
- n개의 키를 가진 B트리는 깊이 == **O(log n)**
- **키 값 찾기**
    - 색인 키를 찾기 위해서는 루트에서 시작
    - 최종적으로는 개별 키(리프 페이지)를 포함하는 페이지에 도달
    - **분기계수** : B 트리의 한 페이지에서 하위 페이지를 참조하는 수
- **키 값 갱신**
    - 리프페이지를 검색하고 페이지의 값을 바꾼 다음 페이지를 디스크에 다시 기록
- **키 값 추가**
    - 새로운 키를 추가하려면 새로운 키를 포함하는 범위의 페이지를 찾아 해당 페이지에 키와 값을 추가

**신뢰 가능한 B트리 만들기**

- B트리의 기본적인 쓰기 동작 : 새로운 데이터를 디스크 상의 페이지에 덮어 씀
    - 페이지의 위치를 변경 X
    - 페이지를 가르키는 모든 참조 유지
- 페이지 기록 도중 DB장애 시, 색인 훼손으로 인해 **고아페이지** 발생 가능
    - 고아 페이지 : 어느 페이지와도 부모 관계가 없는 페이지
- **재시행(redo) 로그**
    - 데이터페이스가 고장 이후 복구될 때 일관성 있는 상태로 B트리를 다시 복원하는데 사용
    - 디스크 상에 쓰기 전 로그 기록
- 다중 스레드가 B 트리 접근 시, 동시성 제어 필요
    - **래치(latch)**로 트리의 데이터 구조 보호
    - 유입 질의의 간섭 없이 백그라운드에서 모든 병합 수행

## B 트리와 LSM 트리 비교

- 구현 성숙도 : B트리가  > LSM트리
- 쓰기 성능 : B트리가  < LSM트리
- 읽기 성능 : B트리가  > LSM트리
    - LSM트리에서 더 느린 이유는 각 컴팩션 단계에 있는 여러가지 데이터 구조와 SS테이블을 확인해야 되기 때문이다.


**LSM 트리의 장점**

- 쓰기 증폭 : 데이터베이스에 쓰기 한 번이 데이터 베이스 수명 동안 디스크에 여러 번의 쓰기를 야기하는 효과
- **압축률**이 더 좋아서 B트리보다 디스크에 더 적은 파일을 생성
- 저장소 엔진은 파편화로 인해 사용하지 않는 디스크 공간 일부가 남음
- LSM 트리는 페이지 지향적이지 않고 주기적으로 파편화를 없애기 위해 SS테이블을 다시 기록 → 저장소 오버헤드가 더 낮음
- 레벨 컴팩션을 사용하면 특히 그렇다.

</br>

**LSM트리의 단점**
- 컴팩션 과정이 진행중인 읽기와 쓰기의 성능에 영향을 줄 수 있음
    - 동시성 영향이 없기 위해 요청을 대기할 수 있음
- 디스크 쓰기 대역폭의 한계
    - 컴팩션 문제 : 높은 쓰기 처리량 발생
    - DB가 커질수록 컴팩션을 위해 더 많은 디스크 대역폭 요구
    - 컴팩션에 대한 모니터링 필요
- B트리는 각 키가 색인의 한 곳에 존재
    - 강려간 트랜잭션 시멘틱 제공

</br>

## 기타 색인 구조

- 기본키 색인
- 보조 색인
- 클러스터드 색인
- 다차원 색인
- 전문 검색 & 퍼지 색인

</br>

**논의주제**  
LSM트리를 활용한 색인은 어떤 데이터베이스에서 활용되는 것인지 궁금합니다!
