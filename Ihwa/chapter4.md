# 4장 부호화와 발전

시스템의 원활한 운영을 위해서는 양방향 호환성이 유지돼야 한다.  
- 하위 호환성 : 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.
- 상위 호환성 : 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.

### 데이터 부호화 형식

- 프로그램은 최소 두가지 형태로 표현된 데이터를 사용해 동작한다.
    - 메모리 객체(object), 구조체(struct), list, array, hash table, tree
- 데이터 구조는 CPU에서 효율적으로 접근하고 조작할 수 있게 최적화된다.
    - 객체, 구조체, 목록, 배열, 해시테이블, 트리 등으로 데이터 유지
- 데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 스스로를 포함한 일련의 **바이트열**의 형태로 부호화 해야한다.
    - **부호화(=직렬화=마샬링)** : 인메모리 표현에서 바이트열로의 전환
    - **복호화(=파싱=역직렬화=연마샬링)** : 바이트열에서 인메모리 표현으로의 전환

</br>

**프로그래밍 언어 내의 내장 부호화 라이브러리** 
- 종류
    - JAVA - java.io.Serializable
    - 루비 - Marshal
    - 파이썬 - pickle
- 내장 부호화 라이브러리의 단점
    - 부호화는 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 데이터를 읽기 매우 어렵다.  
    ->  다른 시스템과 통합하는데 방해가 될 수 있다.
    - 동일한 객체 유형의데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화 할 수 있어야 한다.
    - 데이터 버전 관리는 등한시된다.
    - 효율성도 등한시 되기 쉽다.

</br>

### JSON과 XML, CSV

- 많은 프로그래밍 언어에서 읽고 쓸 수 있는 표준화된 부호화이다.
- 데이터 교환 형식으로 사용하기 매우 좋은 형식들이다.
    - XML - 장황하고 불필요하게 복잡하다고 비판
    - JSON - XML 대비 단순하며 주로 웹 브라우저에 내장된 지원
    - CSV

**위 부호화들의 문제점**

- 수의 부호화에는 많은 애마함이 있으며 이는 큰 수를 다룰 때 문제가 될 수 있다.
    - XML과 CSV에서는 수와 숫자로 구성된 문자열을 구분할 수 없다. (“5”와 5를 구분하지 못하는 문제)
    - JSON은 문자열과 수를 구분하지만 정수와 부동소수점 수를 구별하지 않고 정밀도를 지정하지 않는다.
- JSON과 XML은 유니코드 문자열을 잘 지원하나 이진 문자열을 지원하지 않는다.
- JSON과 XML 모두 스키마를 지원하지만 CSV는 스키마가 없어 매우 모호해질 수 있다.
    - 데이터의 올바른 해석은 스키마의 정보에 따라 다른다.
    - XML/JSON스키마를 사용하지 않는 애플리케이션은 필요한 부호화/복호화 로직을 하드코딩해야 할 가능성이 있다.
    - CSV는 스키마가 없으므로 각 로우와 칼럼의 의미를 정의하는 작업을 애플리케이션이 해야한다.

</br>

## 이진 부호화

- JSON과XML에 비해 더 적은 공간, 더 간결하고 빠른 파싱이다.  
(데이터 셋이 적다면 별 의미 없지만, 테라바이트 급이 된다면 달라짐)
- JSON과 XML 데이터 모델은 스키마를 지정하지 않기 때문에 부호화된 데이터 안에 모든 객체의 필드 이름을 포함해야 한다.

### 이진 부호화 라이브러리

두 라이브러리 모두 데이터를 정의할 스키마가  필요하다.  
스리프트(thrift) 스키마

```yaml
struct Person {
	1: required String        userName,
	2: optional i64           favoriteNumber,
	3: optional list<String>  interests
}
```

프로토콜 버퍼(protocol buffer) 스키마  
```yaml
message Person {
	required string username        = 1;
	optional int64  favorite_number = 2;
	repeated string interests       = 3;
}
```

**스리프트**  
- 페이스북에서 개발
- 스리프트 인터페이스 정의 언어로 스키마를 기술해야 한다.
- 이진 부호화 형식
    - 바이너리 프로토콜
        - 각 필드는 타입에 대한 주석이 필요하며 필요한 경우 길이 표시가 있다.
        - 데이터에 나타난 문자열도 아스키로 부호화하한다.
        - 필드 이름이 없는 대신 부호화된 데이터 숫자와 같은 `필드 태그` 를 포함한다. 
        (부호화 스키마에 정의됨)
    - 컴팩트 프로토콜
        - 필드 타입과 태그 숫자를 단일 바이트로 줄였다.
        - 가변 정수를 사용해 부호화한다.
        - 각 바이트의 상위 비트는 앞으로 더 많은 바이트가 있는지 나타내는 데 사용한다.

**프로토콜 버퍼**  
- 구글에서 개발되었다.
- 동일한 데이터를 부호화 → 33바이트로 만든다.

</br>

### 필드 태그와 스키마의 발전

**스키마의 발전**

- 스키마는 필연적으로 시간이 지남에 따라 변한다.
- 부호화된 데이터는 필드 이름은 참조하지 않기 때문에 변경 가능하다.
- 필드 태그의 변경은 이미 부호화된 데이터를 인식할 수 없기 때문에 변경이 불가능하다.  
이는 스키마에 새로운 필드를추가하여 새로운 태그 번호를 부여하는 방식으로 추가한다.  
→ 태그 번호를 통해 예전 코드가 새로운 코드로 기록된 레코드를 읽을 수 있다.(상위 호환)  
- 각 필드의 고유한 태그 번호가 있으므로 새로운 코드가 예전 데이터 읽을 수 있으며 (하위 호환)  
하위 호환을 위해서는 `optional` 로 하거나 기본값을 가져야 한다.
- 필드를 삭제하는 방법 : 필드 추가 시 하위 호환성과 상위 호환성 문제를 해결하는 방식과 반대로 한다.   
`optional` 필드 삭제 가능 / 같은 태그 번호 재사용 금지

## 아브로

- 스리프트가 하둡의 사용 사례에 적합하지 않아 2009년 하둡의 하위 프로젝트로 시작했다.
- 두개의 스키마 언어 존재한다. → IDL(사람이 편집 가능) / JSON기반 언어(기계가 더 쉽게 읽음)
- 부호화 데이터 구조 지정을 위해 스키마를 사용했으나 태그번호는 없다.
- 데이터타입을 식별하기 위한 정보가 없다.
- 부호화는 단순히 연결된 값으로 구성된다.
- 파싱을 위해서는 스키마에 나타난 수서대로 필드를 보고 각 필드 데이터타입을 미리 파악해야 한다.
    - 데이터 코드를 읽는 코드가 데이터를 기록한 코드와 정확히 같은 스키마를 사용하는 경우에만 이진 데이터를 올바르게 복호화할 수 있음을 의미한다.

    
```java
record Person {
    string   userName;
    union{ null, long } favoriteNumber = null;
    array<string> interests;
}
```

```yaml
{
    "type": "record",
    "name": "Person",
    "fields": [
    { "name": "userName", "type": "string"},
    { "name": "favoriteNumber", "type": [ "null", "long" ], "default": null},
    { "name": "interests", "type": { "type": "array", "items": "string" }}
    ]
}
```

<br/>

### 쓰기 스키마와 읽기 스키마

- 쓰기 스키마
    - 파일이나 데이터베이스에 쓰기 또는 네트워크를 전송 등의 목적으로 데이터를 아브로로 부호화하기 위해서는 스키마 버전을 사용해 데이터를 부호화 한다.
    - 애플리케이션에 이 스키마를 포함할 수 있다.
- 읽기 스키마
    - 파일이나 데이터베이스에서 또는 네트워크로부터 수신 등으로 읽은 어떤 데이터를 복호화하기를 원한다면 데이터가 특정 스키마로 복호화하길 기대한다.
    - 애플리케이션 코드는 이 스키마에 의존한다.
    - 복호화 코드는 애플리케이션 빌드 동안 스키마에서 생성된다.

- 아브로의 핵심 아이디어
    - 쓰기 스키마와 읽기 스키마가 동일하지 않아도 호환만 가능하면 된다.
    - 아브로 라이브러리는 데이터를 복호화 할 때 쓰기 스키마와 읽기 스키마 분석 후 변환해 그 차이를 해소한다.
        - 스키마 해석에서는 필드를 이름으로 일치시키기 때문에 쓰기 스키마와 읽기 스키마의 필드 순서가 달라도 문제 없다.
        - 쓰기 스키마에 존재하나 읽기 스키마에 없는 경우는 무시한다.
        - 쓰기 스키마에는 없으나 읽기 스키마에만 존재하는 경우 읽기 스키마의 기본값으로 채운다.
        
<br/>

### 스키마 발전 규칙

호환성을 유지를 위해서는 기본값이 있는 필드만 추가하거나 삭제할 수 있다.   
→ 누락된 필드는 기본값으로 채워진다.

아브로는 
- 필드에 `Null`을 허용하려면 유니온 타입을 사용해야 한다.
    - 유니온 타입 : union{null, long, string} field;는 수나 문자열 또는 널일 수 있다는 의미다.   
    → 필드가 유니온 엘리먼트 중 하나인 경우에만 기본값으로 널을 사용할 수 있다.  
- 프로토콜 버퍼, 스리프트와 동일한 방식의 optional과 required표시자를 가지고 있지 않다.  
→ 대신 유니온 타입과 기본값이 있다.
- 타입을 변환할 수 있으므로(읽기스미아에만 있는 경우 default value로 채우는 것?) 필드의 데이터타입 변경이 가능하다.   
(이름도 변경 가능) → 하위 호환성이 있지만 상위 호환성은 없다.

</br>

**아브로가 쓰기 스키마를 찾아가는 방법**  
- 많은 레코드가 있는 대용량 파일
    - 아브로의 일반적인 용도 : 모두 동일한 스키마로 부호화된 수백만 개 레코드를 포함한 큰 파일을 저장하는 용도
    - 파일의 쓰기는 파일의 시작 부분에 한 번만 쓰기 스키마를 포함시키면 된다.
    - 아브로는 이를 위해 파일 형식(객체 컨테이너 파일)을 명시한다.
- 개별적으로 기록된 레코드를 가진 데이터베이스
    - 데이터베이스의 다양한 레코드들은 다양한 쓰기 스키마를 사용해 서로 다른 시점에 쓰여질 수 있다.   
    즉, 모든 레코드가 동일한 스키마를 가진다고 가정할 수 없다.
    - 레코드의 시작 부분에 버전 번호를 포함하고 데이터베이스에는 스키마의 버전별 히스토리를 보관한다.
    - 읽기 스키마에서 버전 번호를 추출하여 해당하는 쓰기 스키마를 가져올 수 있다.
- 네트워크 연결  
 연결 설정 시 스키마 버전 합의를 할 수 있으며 연결을 유지하는 동안 합의된 스키마를 사용한다.  
 아브로 RPC프로토콜이 이처럼 동작한다.

</br>

### 동적 생성 스키마

- 아브로는 스키마에 태그 번호가 없어 동적 스키마에 더 친숙하다.
    - RDB 스키마로부터 아브로 스키마를 상당히 쉽게 생성할 수 있다.
        - 각 데이터베이스 테이블에 맞게 레코드 스키마를 생성하고 각 칼럼은 해당 레코드의 필드가 된다.
        - 데이터베이스의 칼럼 이름은 아브로의 필드 이름에 매핑된다.
    - RDB 내의 스키마가 변경되면 갱시된 스키마로부터 새로운 아브로 스키마를 생성하여 내보낸다.
- 이에 반해 스리프트나 프로토콜 버퍼를 이런 용도로 사용한다면 데이터베이스 스키마가 변경될 때마다 관리자는 데이터베이스 칼럼 이름과 필드 태그의 매핑을 수동으로 갱신해야 한다.

→ 아브로는 동적 생성 스키마를 고려해 설계했기 때문이다.

**코드 생성과 동적 타입 언어**  
- 스리프트와 프로토콜 버퍼는 코드 생성에 의존한다.
- 스키마를 정의한 후 선택한 프로그래밍 언어로 스키마를 구현한 코드를 생성할 수 있다.
- 코드 생성 시점이 컴파일 시점이기 때문에 스키마 변경시 컴파일을 다시 해야한다.
- 아브로는 코드 생성 없이도 사용할 수 있지만 정적 타입 프로그래밍 언어를 위해 코드 생성을 선택적으로 제공한다. 
- 객체 컨테이너 파일이 있다면 아브로 라이브러리를 사용해 간단히 열어 JSON파일을 보는 것과 같이 데이터를 볼 수 있다.   
이 파일은 필요한 메타데이터를 모두 포함하기 때문에 **자기 기술적**이다.

</br>

### 스키마의 장점

- 스키마 언어는 xml 스키마나 JSON 스키마보다 훨씬 간단하며 더 자세한 유효성 검사 규칙을 지원한다.  
많은 데이터 시스템이 이진 부호화를 독자적으로 구현하기도 한다.
- 질의를 데이터베이스로 보내고 응답을 받을 수 있는 네트워크 프로토콜
- 특정 데이터베이스에 특화되고 데이터베이스 벤더는 데이터베이스 네트워크 프로토콜로부터 응답을 인메모리 데이터 구조로 복호화하는 드라이버를 제공한다.

<br/>

**스키마를 기반으로 한 이진 부호화 장점**
- 부호화된 데이터에서 필드 이름을 생략할 수 있기 때문에 다양한 “이진 JSON” 변형보다 크기가 훨씬 작을 수 있다.
- 복호화를 할 때 스키마가 필요하기 때문에 스키마가 최신 상태인지를 확신할 수 있다.
- 스키마 데이터베이스를 유지하면 스키마 변경이 적용되기 전에 상위 호환성과 하위 호환성을 확인할 수 있다.
- 정적 타입 프로그래밍 언어의 경우 컴파일 시점에 타입 체크가 가능하다.


</br>

## 데이터플로 모드

- 매우 추상적인 개념
- 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 방법은 많음

프로세스 간 데이터를 전달하는 가장 보편적인 방법을 알아감

**데이터베이스를 통한 데이터플로**  
- 데이터베이스에 기록하는 프로세스 : 데이터 부호화
- 데이터베이스에서 읽는 프로세스 : 데이터 복호화
- 단일 프로세스 접근
    - 읽기는 단순히 동일 프로세스의  최신 버전이다.
    - 저장하는 일을 미래의 자신에게 메시지를 보내는 일처럼 생각할 수 있다.
        - 미래의 내가 읽을 수 있도록 하위 호환성이 필요하다.
- 다중 프로세스 접근
    - 각 프로세스가 다른 버전으로 접근할 수 있다.   
    이는 새로운 버전의 코드로 기록된 다음 예전 버전의 코드가 그 값을 읽을 가능성이 있다는 것으로 상위 호환성도 필요하다.  
    - 여러 부호화 형식은 알지 못하는 필드의 보존은 지원하나 애플리케이션 차원에서 신경 써야 하는 사례도 있다.
        - 애플리케이션에서 데이터베이스 값을 모델 객체로 복호화하고 나중에 이 모델 객체를 다시 재부호화 한다면 변환 과정에서 알지 못하는 필드가 유실될 수 있다.
- 다양한 시점에 기록된 다양한 데이터
    - 데이터가 코드보다 더 오래 산다.
    (5년된 데이터는 그 이후로 명시적으로 다시 기록되지 않는 한 원래의 부호화 상태 그대로 있음)
    - 데이터를 새로운 스키마로 다시 기록(마이그레이션)하는 작업은 분명 가능하나 대용량 데이터셋 대상으로는 값비싼 작업으로 대부분의 데이터베이스에서 가능하면 이런 상황을 피한다.
    - 대부분의 관계형 데이터베이스는 기존 데이터를 다시 기록하지 않고 널을 기본값으로 갖는 새로운 칼럼을 추가하는 간단한 스키마 변경을 허용한다.

스키마 발전은 기본 저장소가 여러가지 버전의 스키마로 부호화된 레코드를 포함해도 전체 데이터베이스가 단일 스키마로 부호화된 것처럼 보이게 한다.


### **서비스를 통한 데이터플로:REST와 RPC**

네트워크로 통신해야하는 프로세스가 있을 때 해당 통신을 배치하는 몇가지 방법  
- 클라이언트와 서버의 두 역할로 배치
    - 서버 : 네트워크를 통해 API를 공개(서비스)
    - 클라이언트 : 이 API로 요청을 만들어 서버에 연결
- 서버 자체가 다른 서비스의 클라이언트일 수 있다.   
하나의 서비스가 다른 서비스의 일부 기능이나 데이터가 필요하다면 해당 서비스에 요청을 보낸다.  
    - SOA(서비스 지향 설계) → 최근 : 마이크로서비스 설계(MSA)   
    → **목표: 서비스를 배포와 변경에 독립적으로 만들어 애플리케이션 변경과 유지보수를 더 쉽게 할 수 있게 만드는 것**
- 서비스는 데이터베이스와 유사 : 임의 질으를 허용하는 반면 서비스는 서비스의 비즈니스로직으로 미리 정해진 입력과 출력만 허용한 애플리케이션 특화 API를 공개(약간의 캡슐화 제공)

</br>

**웹 서비스**  
서비스와 통신을 위해 기본 프로토콜로 HTTP를 사용할 때 웹서비스라고 함

- REST
    - HTTP의 원칙을 토대로 한 설계 철학
    - 간단한 데이터 타입을 강조
    - URL을 사용해 리소스를 식별하고 캐시 제어, 인증, 콘텐츠 유형 협상에 HTTP 기능을 사용
    - 적어도 조직 간 서비스 통합과 관련해서는 SOAP에비해 인기를 얻음
    - 종종 마이크로서비스와 연관되기도 함
    - REST원칭에 따라 설계된 API를 RESTful이라고 함
- SOAP
    - 네트워크 API요청을 위한 XML기반 프로토콜
    - HTTP상에사 가장 일반적으로 사용되지만 HTTP와 독립적이며 대부분의 HTTP기능을 사용하지 않음
    - 다양한 기능을 추가한 광범위하고 봊갑한 여러 관련 표준(웹 서비스 플레임워크)를 제공
    - SOAP 웹 서비스의 API는 웹 서비스 기술언어 또는 WSDL이라고 부르는 XML기반 언어를 사용해 기술
        - WSDL : 클라이언트가 로컬 클래스와 메서드 호출을 사용해 원격 서비스에 접근하는 코드 생성 가능  
        → 정적 타입 프로그래밍 언어에는 유용하지만 동적 타입 언어에는 유용성 떨어짐
    - 사용자는 도구 지원과 코드 생성과 IDE에 크게 의존
    - 벤더가 지원하지 않는 프로그래밍 언어 사용자의 경우 통합은 어렵다.
    - 상호운용성은 종종 문제를 일으킴

</br>

**원격 프로시저 호출(RPC)문제**  
- 웹 서비스는  네트워크 상에서 API 요청을 위한 여러 기술 중 가장 최신 형상이나 여러 문제가 있다.
- 이러한 웹 서비스는 원격 프로시저 호출의 아이디어를 기반으로 한다.
- RPC모델은 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용 가능하게 해준다. (=위치 투명성)
- 근본적 결함
    - 네트워크 요청은 로컬 함수 호출과는 매우 다르다.
    - 로컬 함수 호출은 예측 가능하나 네트워크 요청은 예측이 어렵다.

**네트워크 요청의 단점**
- 로컬함수 호출은 결과를 반환하거나 예외를 내거나 반환하지 않을 수 있으나  
네트워크 요청은 타임아웃으로 결과 없이 반환될 수 있어 무슨 일인지 알기 어렵다.
- 실패한 네트워크 요청을 다시 시도할 때 요청이 실제로는 처리되고 응답만 유실될 수 있다.   
→ 프로토콜에 중복 제거기법(멱등성)을 적용하지 않으면 재시도 작업이 여러번 수행되는 원인이 된다.   
→ 로컬함수는 이런 문제가 없다.
- 로컬함수를 호출할 때마다 보통 거의 같은 실행 시간이 소요된다.   
→ 네트워크 요청은 함수 호출보다 훨씬 느리고 지연 시간은 매우 다양하다.
- 로컬 함수를 호출하는 경우 참조(포인터)를 로컬 메모리의 객체에 효율적으로 전달할 수 있으나   
네트워크로 요청하는 경우 모든 매개변수는 네트워크를 통해 전송할 수 있게끔 바이트열로 부호화해야 한다.
- 클라이언트와 서비스는 다른 프로그래밍 언어로 구현할 수 있다.

→ REST의 장점은 네트워크 프로토콜이라는 사실을 숨기려 하지 않는다는 점

**RPC의 현재 방향**  
차세대 RPC프레임워크는 원격 요청이 로컬 함수 호출과 다르다는 사실을 더욱 분명히 한다.  
→ 비동기 작업을 캡슐화하기 위해 퓨처(promise)를 사용 : 병렬로 여러 서비스에 요청을 보내야 하는 상황을 간소화하고 요청 결과를 취합

**RESTful API의 이점**  
- 실험과 디버깅에 적합하다.
- 모든 주요 프로그래밍 언어와 플랫폼이 지원한다.
- 사용 가능한 다양한 도구 생태계(서버, 캐시 로드 밸런서, 프락시, 방화벽, 모니터링, 디버깅 도구, 테스팅 도구)가 있다.

</br>

### 메시지 전달 데이터플로

**비동기 메시지 전달 시스템**

- 클라이언트 요청을 낮은 지연 시간으로 다른 프로세스에 전달한다는 점에서 RPC와 비슷하다.
- 메시지를 직접 네트워크로 전송하지 않고 임시로 메시지를 저장하는 `메시지 브로커` 나 `메시지 지향 미들웨어` 라는 중간 단계를 거쳐 전송한다는 점은 데이터베이스와 유사하다.
- 메시지 브로커 장점
    - 수신자가 사용 불가능하거나 과부하 상태라면 메시지 브로커가 버퍼처럼 동작할 수 있기 대문에 시스템 안정성이 향상된다.
    - 죽었던 프로세스에 메세지를 다시 전달할 수 있기 때문에 메시지 유실 방지가 가능하다.
    - 송신자가 수신자의 IP주소나 포트 번호를 알 필요가 없다.
    - 하나의 메시지를 여러 수신자로 결정 가능하다.
    - 논리적으로 송신자는 수신자의 분리된다할 뿐이고 누가 소비하는지 상관하지 않는다.
- 메시지 통신은 일반적으로 단방향이라는 점이 RPC와 다르다.
송신 프로세스는 메시지에 대한 응답을 기대하지 않는다.

</br> 

**메시지 브로커**

- 최근에는 RabbitMQ, ActiveMQ, NATS, Apache Kafka 같은 오픈소스 구현이 대중화 됐다.
- 세부적인 전달 시맨틱은 구현과 설정에 따라 다양하다.
- 프로세스 하나가 메시지를 이름이 지정된 `큐`나 `토픽`으로 전송하고   
브로커는 해당 `큐`나 `토픽` 하나 이상의 소비자 또는 구독자에게 메세지를 전달한다.  
- 동일한 토픽에 여러 생산자와 소비자가 있을 수 있다.
- 토픽은 단방향 데이터플로만 제공한다.
- 소비자 스스로 메세지를 다른 토픽으로 게시하거나 원본 메시지의 송신자가 소비하는 응답큐로 게시할 수 있다.  
- 메시지 브로커는 보통 특정 데이터 모델을 강요하지 않는다.  
→ 일부 메타데이터를 가진 바이트열이므로 모든 부호화 형식을 사용할 수 있다.  
→ 부호화가 상하위 호환성을 모두 가진다면 메시지 브로커에게 게시자와 소비자를 독립적으로 변경해 임의 순서로 배포할 수 있는 유연성을 얻게된다.

<br/>

### 분산 액터 프레임워크

- 액터 모델은 단일 프로세스 안에서 동시성을 위한 프로그래밍 모델이다.
- 스레드(경쟁 조건, 잠금, 교착 상태와 연관된 문제들)를 직접 처리하는 대신 로직이 액터에 캡슐화된다.
- 각 액터는 하나의 클라이언트나 엔티티를 나타낸다.
    - 액터는 로컬 상태를 가질 수 있고 비동기 메시지의 송수신으로 다른 액터와 통신한다.
- 액터는 메시지 전달을 보장하지 않는다.  
어떤 에러 상황에서 메시지는 유실될 수 있다. → 위치 투명성은 RPC보다 액터 모델에서 더 잘 동작한다.
- 비록 네트워크를 통한 지연 시간이 동일한 프로세스 안에서 보다 더 높을 수 있지만   
액터 모델을 사용한 경우 로컬과 원격 통신 간 근본적인 불일치가 적다.
- 액터 프로세스는 한 번에 하나의 메시지만 처리하기 때문에 스레드에 대해 걱정할 필요가 없고   
각 액터는 프레임워크와 독립적으로 실행할 수 있다.